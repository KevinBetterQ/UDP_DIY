; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\SDRAM\skbuff.o --asm_dir=.\SDRAM\ --list_dir=.\SDRAM\ --depend=.\SDRAM\skbuff.d --cpu=ARM920T --apcs=interwork -O0 -I..\Common\Inc -I.\INC -I.\INC\tftp -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Samsung --omf_browse=.\SDRAM\skbuff.crf Source\tftp\skbuff.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  skb_init PROC
;;;6      
;;;7      int skb_init(void)
000000  e3a00000          MOV      r0,#0
;;;8      {
;;;9      	return 0;
;;;10     }
000004  e12fff1e          BX       lr
;;;11     
                          ENDP

                  skb_headerinit PROC
;;;12     void skb_headerinit(struct sk_buff *skb)
000008  e92d4010          PUSH     {r4,lr}
;;;13     {
00000c  e1a04000          MOV      r4,r0
;;;14     	memset(skb, 0, sizeof(struct sk_buff));
000010  e59f20fc          LDR      r2,|L1.276|
000014  e3a01000          MOV      r1,#0
000018  e1a00004          MOV      r0,r4
00001c  ebfffffe          BL       memset
;;;15     
;;;16     	skb->data = skb->buf;
000020  e2840002          ADD      r0,r4,#2
000024  e58405f0          STR      r0,[r4,#0x5f0]
;;;17     	skb->len = 0;
000028  e3a00000          MOV      r0,#0
00002c  e58405f4          STR      r0,[r4,#0x5f4]
;;;18     	skb->truesize = ETH_FRAME_LEN;
000030  e59f00e0          LDR      r0,|L1.280|
000034  e58405ec          STR      r0,[r4,#0x5ec]
;;;19     }
000038  e8bd4010          POP      {r4,lr}
00003c  e12fff1e          BX       lr
;;;20     
                          ENDP

                  alloc_skb PROC
;;;21     struct sk_buff *alloc_skb(unsigned int size)
000040  e92d4070          PUSH     {r4-r6,lr}
;;;22     {
000044  e1a05000          MOV      r5,r0
;;;23     	struct sk_buff *skb;
;;;24     	
;;;25     	skb = &skbuff[skb_cur];
000048  e59f00cc          LDR      r0,|L1.284|
00004c  e5900000          LDR      r0,[r0,#0]  ; skb_cur
000050  e0601300          RSB      r1,r0,r0,LSL #6
000054  e0810380          ADD      r0,r1,r0,LSL #7
000058  e59f10c0          LDR      r1,|L1.288|
00005c  e0814180          ADD      r4,r1,r0,LSL #3
;;;26     	skb_cur++;
000060  e59f00b4          LDR      r0,|L1.284|
000064  e5900000          LDR      r0,[r0,#0]  ; skb_cur
000068  e2800001          ADD      r0,r0,#1
00006c  e59f10a8          LDR      r1,|L1.284|
000070  e5810000          STR      r0,[r1,#0]  ; skb_cur
;;;27     	if(skb_cur>=5)
000074  e2810000          ADD      r0,r1,#0
000078  e5900000          LDR      r0,[r0,#0]  ; skb_cur
00007c  e3500005          CMP      r0,#5
000080  ba000001          BLT      |L1.140|
;;;28     		skb_cur = 0;
000084  e3a00000          MOV      r0,#0
000088  e5810000          STR      r0,[r1,#0]  ; skb_cur
                  |L1.140|
;;;29     	skb_headerinit(skb);
00008c  e1a00004          MOV      r0,r4
000090  ebfffffe          BL       skb_headerinit
;;;30     	return skb;
000094  e1a00004          MOV      r0,r4
000098  e8bd4070          POP      {r4-r6,lr}
;;;31     }
00009c  e12fff1e          BX       lr
;;;32     
                          ENDP

                  free_skb PROC
;;;33     void free_skb(struct sk_buff *skb)
0000a0  e12fff1e          BX       lr
;;;34     {
;;;35     }
;;;36     
                          ENDP

                  skb_put PROC
;;;37     unsigned char *skb_put(struct sk_buff *skb, unsigned int len)
0000a4  e1a02000          MOV      r2,r0
;;;38     {
;;;39     	skb->len += len;
0000a8  e59205f4          LDR      r0,[r2,#0x5f4]
0000ac  e0800001          ADD      r0,r0,r1
0000b0  e58205f4          STR      r0,[r2,#0x5f4]
;;;40     	return skb->data;
0000b4  e59205f0          LDR      r0,[r2,#0x5f0]
;;;41     }
0000b8  e12fff1e          BX       lr
;;;42     
                          ENDP

                  skb_pull PROC
;;;43     unsigned char *skb_pull(struct sk_buff *skb, unsigned int len)
0000bc  e1a02000          MOV      r2,r0
;;;44     {
;;;45     	skb->data += len;
0000c0  e59205f0          LDR      r0,[r2,#0x5f0]
0000c4  e0800001          ADD      r0,r0,r1
0000c8  e58205f0          STR      r0,[r2,#0x5f0]
;;;46     	skb->len -= len;
0000cc  e59205f4          LDR      r0,[r2,#0x5f4]
0000d0  e0400001          SUB      r0,r0,r1
0000d4  e58205f4          STR      r0,[r2,#0x5f4]
;;;47     	return skb->data;
0000d8  e59205f0          LDR      r0,[r2,#0x5f0]
;;;48     }
0000dc  e12fff1e          BX       lr
;;;49     
                          ENDP

                  skb_push PROC
;;;50     unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
0000e0  e1a02000          MOV      r2,r0
;;;51     {
;;;52     	skb->data -= len;
0000e4  e59205f0          LDR      r0,[r2,#0x5f0]
0000e8  e0400001          SUB      r0,r0,r1
0000ec  e58205f0          STR      r0,[r2,#0x5f0]
;;;53     	skb->len += len;
0000f0  e59205f4          LDR      r0,[r2,#0x5f4]
0000f4  e0800001          ADD      r0,r0,r1
0000f8  e58205f4          STR      r0,[r2,#0x5f4]
;;;54     	return skb->data;
0000fc  e59205f0          LDR      r0,[r2,#0x5f0]
;;;55     }
000100  e12fff1e          BX       lr
;;;56     
                          ENDP

                  skb_reserve PROC
;;;57     void skb_reserve(struct sk_buff *skb, unsigned int len)
000104  e59025f0          LDR      r2,[r0,#0x5f0]
;;;58     {
;;;59     	skb->data += len;
000108  e0822001          ADD      r2,r2,r1
00010c  e58025f0          STR      r2,[r0,#0x5f0]
;;;60     }
000110  e12fff1e          BX       lr
;;;61     
                          ENDP

                  |L1.276|
                          DCD      0x000005f8
                  |L1.280|
                          DCD      0x000005ea
                  |L1.284|
                          DCD      skb_cur
                  |L1.288|
                          DCD      skbuff

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  skbuff
                          %        7640

                          AREA ||.data||, DATA, ALIGN=2

                  skb_cur
                          DCD      0x00000000

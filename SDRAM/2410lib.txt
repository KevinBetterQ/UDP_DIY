; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\SDRAM\2410lib.o --asm_dir=.\SDRAM\ --list_dir=.\SDRAM\ --depend=.\SDRAM\2410lib.d --cpu=ARM920T --apcs=interwork -O0 -I..\Common\Inc -I.\INC -I.\INC\tftp -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Samsung --omf_browse=.\SDRAM\2410lib.crf ..\common\src\2410lib.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  port_init PROC
;;;32     *********************************************************************************************/
;;;33     void port_init(void)
000000  e59f0934          LDR      r0,|L1.2364|
;;;34     {
;;;35         //CAUTION:Follow the configuration order for setting the ports. 
;;;36         // 1) setting control register (GPnCON)
;;;37         //    * (bitn) -- means this pin not use on circuit, and set as default function
;;;38         // 2) configure pull-up resistor (GPnUP)  
;;;39         // 3) setting value (GPnDAT)
;;;40     
;;;41         //32bit data bus configuration  
;;;42         //=== PORT A GROUP
;;;43         //Ports  : GPA22  GPA21  GPA20  GPA19  GPA18  GPA17  GPA16  GPA15  GPA14  GPA13  GPA12  
;;;44         //Signal : nFCE   GPA21  nFRE   nFWE   ALE    CLE    GPA16  nGCS4  nGCS3  nGCS2  nGCS1 
;;;45         //Setting: nFCE   Output nFRE   nFWE   ALE    CLE    Output nGCS4  nGCS3  nGCS2  nGCS1 
;;;46         //Binary : 1      *0      1,     1      1      1      *0,    1      1      1      1
;;;47         //----------------------------------------------------------------------------------------
;;;48         //Ports  : GPA11  GPA10   GPA9   GPA8   GPA7   GPA6   GPA5   GPA4   GPA3   GPA2   GPA1   GPA0
;;;49         //Signal : GPA11 ADDR25  ADDR24 ADDR23 ADDR22 ADDR21 ADDR20 ADDR19 ADDR18 ADDR17 ADDR16 ADDR0 
;;;50         //Binary : *0     1       1      1,     1      1      1      1,     1      1      1      1         
;;;51         rGPACON = 0x5fbfff;
000004  e3a01456          MOV      r1,#0x56000000
000008  e5810000          STR      r0,[r1,#0]
;;;52     
;;;53         //===* PORT B GROUP
;;;54         //Ports  : GPB10  GPB9   GPB8   GPB7   GPB6   GPB5    GPB4    GPB3   GPB2   GPB1  GPB0
;;;55         //Signal : GPB10  GPB9   GPB8   GPB7   GPB6   DIS_OFF L3CLOCK L3DATA L3MODE PWM2  PWM1
;;;56         //Setting: Output Output Output Output Output Output  Output  Output Output TOUT1 TOUT0 
;;;57         //Binary : 01,    01     *01,   *01    *01,   01      01,     01     01,    10    10  
;;;58         rGPBCON = 0x155559;
00000c  e59f092c          LDR      r0,|L1.2368|
000010  e5810010          STR      r0,[r1,#0x10]
;;;59         rGPBUP  = 0x7ff;      // The pull up function is disabled GPB[10:0]
000014  e59f0928          LDR      r0,|L1.2372|
000018  e5810018          STR      r0,[r1,#0x18]
;;;60     
;;;61         //=== PORT C GROUP
;;;62         //Ports  : GPC15 GPC14 GPC13 GPC12 GPC11 GPC10 GPC9 GPC8 GPC7   GPC6   GPC5   GPC4 GPC3   GPC2  GPC1 GPC0
;;;63         //Signal : VD7   VD6   VD5   VD4   VD3   VD2   VD1  VD0  Output Output Output OUT   VFRAME VLINE VCLK LEND  
;;;64         //Binary : 10    10,   10    10,   10    10,   10   10,  *01    *01,   *01    01,  10     10,   10   10
;;;65         rGPCCON = 0xaaaa55aa;       
00001c  e59f0924          LDR      r0,|L1.2376|
000020  e5810020          STR      r0,[r1,#0x20]
;;;66         rGPCUP  = 0xffff;     // The pull up function is disabled GPC[15:0] 
000024  e0200460          EOR      r0,r0,r0,ROR #8
000028  e5810028          STR      r0,[r1,#0x28]
;;;67     
;;;68         //=== PORT D GROUP
;;;69         //Ports  : GPD15 GPD14 GPD13 GPD12 GPD11 GPD10 GPD9 GPD8 GPD7 GPD6 GPD5 GPD4 GPD3 GPD2 GPD1 GPD0
;;;70         //Signal : VD23  VD22  VD21  VD20  VD19  VD18  VD17 VD16 VD15 VD14 VD13 VD12 VD11 VD10 VD9  VD8
;;;71         //Binary : 10    10,   10    10,   10    10,   10   10,  10   10,  10   10,  10   10,  10   10
;;;72         rGPDCON = 0xaaaaaaaa;       
00002c  e59f0918          LDR      r0,|L1.2380|
000030  e5810030          STR      r0,[r1,#0x30]
;;;73         rGPDUP  = 0xffff;     // The pull up function is disabled GPD[15:0]
000034  e59f0914          LDR      r0,|L1.2384|
000038  e5810038          STR      r0,[r1,#0x38]
;;;74     
;;;75         //=== PORT E GROUP
;;;76         //Ports  : GPE15  GPE14  GPE13  GPE12   GPE11   GPE10   GPE9    GPE8     GPE7  GPE6  GPE5   GPE4  
;;;77         //Signal : IICSDA IICSCL SPICLK SPIMOSI SPIMISO SDDATA3 SDDATA2 SDDATA1 SDDATA0 SDCMD SDCLK I2SSDO 
;;;78         //Binary : 10     10,    10     10,     10      10,     10      10,      10    10,   10     10,       
;;;79         //----------------------------------------------------------------------------------------
;;;80         //Ports  :  GPE3   GPE2  GPE1    GPE0    
;;;81         //Signal : I2SSDI CDCLK I2SSCLK I2SLRCK     
;;;82         //Binary :  10     10,    10      10 
;;;83         rGPECON = 0xa6aaaaaa;       
00003c  e59f0910          LDR      r0,|L1.2388|
000040  e5810040          STR      r0,[r1,#0x40]
;;;84         rGPEUP  = 0xffff;     // The pull up function is disabled GPE[15:0]
000044  e59f0904          LDR      r0,|L1.2384|
000048  e5810048          STR      r0,[r1,#0x48]
;;;85     	rGPEDAT = 0x2000;
00004c  e3a00a02          MOV      r0,#0x2000
000050  e5810044          STR      r0,[r1,#0x44]
;;;86         //=== PORT F GROUP
;;;87         //Ports  : GPF7   GPF6   GPF5   GPF4   GPF3    GPF2      GPF1    GPF0
;;;88         //Signal : LED_4  LED_3  LED_2  LED_1  PS2_INT CPLD_INT1 KEY_INT BUT_INT1
;;;89         //Setting: Output Output Output Output EINT3   EINT2     EINT1   EINT0
;;;90         //Binary : 01     01,    01     01,    10      10,       10      10
;;;91         rGPFCON = 0x55aa;
000054  e59f08fc          LDR      r0,|L1.2392|
000058  e5810050          STR      r0,[r1,#0x50]
;;;92         rGPFUP  = 0xff;     // The pull up function is disabled GPF[7:0]
00005c  e3a000ff          MOV      r0,#0xff
000060  e5810058          STR      r0,[r1,#0x58]
;;;93     
;;;94         //=== PORT G GROUP
;;;95         //Ports  : GPG15 GPG14 GPG13 GPG12 GPG11  GPG10  GPG9      GPG8      GPG7    GPG6    
;;;96         //Signal : nYPON YMON  nXPON XMON  GPG11  SD_CD  CPLD_INT3 CPLD_INT2 SPICLK1 SPIMOSI
;;;97         //Setting: nYPON YMON  nXPON XMON  Output Iutput EINT17    EINT17    SPICLK1 SPIMOSI1
;;;98         //Binary : 11    11,   11    11,   01     00,    10        10,       11      11
;;;99         //---------------------------------------------------------------------------------------
;;;100        //Ports  : GPG5     GPG4      GPG3     GPG2 GPG1    GPG0    
;;;101        //Signal : SPIMISO1 LCD_PWREN BUT_INT2 nSS0 NET_INT GPG0
;;;102        //Setting: SPIMISO1 LCD_PWRDN EINT11   nSS0 EINT9   Output
;;;103        //Binary : 11       11,       10       11,  10      *01
;;;104        rGPGCON = 0xff4af7b9;
000064  e59f08f0          LDR      r0,|L1.2396|
000068  e5810060          STR      r0,[r1,#0x60]
;;;105        rGPGUP  = 0xffff;    // The pull up function is disabled GPG[15:0]
00006c  e59f08dc          LDR      r0,|L1.2384|
000070  e5810068          STR      r0,[r1,#0x68]
;;;106    
;;;107        //rGPGCON = (rGPGCON & 0xfffffcff) | (1<<8);	// GPG4 [9:8] 11  -> LCD_PWREN Enable
;;;108        // Eable LCD 
;;;109        // rGPGDAT = (rGPGDAT & 0xffef) | (1<<4);
;;;110        // close LCD 
;;;111        rGPGDAT = rGPGDAT & 0xffcf;
000074  e3a00456          MOV      r0,#0x56000000
000078  e5900064          LDR      r0,[r0,#0x64]
00007c  e59f18dc          LDR      r1,|L1.2400|
000080  e0000001          AND      r0,r0,r1
000084  e3a01456          MOV      r1,#0x56000000
000088  e5810064          STR      r0,[r1,#0x64]
;;;112    
;;;113        //=== PORT H GROUP
;;;114        //Ports  : GPH10 GPH9     GPH8   GPH7  GPH6  GPH5 GPH4 GPH3 GPH2 GPH1  GPH0 
;;;115        //Signal : GPH10  CLKOUT0 SD_WP  CTS1  RTS1  RXD1 TXD1 RXD0 TXD0 nRTS0 nCTS0
;;;116        //Setting: Output CLKOUT0 GPH8   nCTS1 nRTS1 RXD1 TXD1 RXD0 TXD0 nRTS0 nCTS0
;;;117        //Binary : 10,    10      10,    11    11,   10   10,  10   10,  10    10
;;;118        rGPHCON = 0x2aaaaa;
00008c  e59f08d0          LDR      r0,|L1.2404|
000090  e5810070          STR      r0,[r1,#0x70]
;;;119        rGPHUP  = 0x7ff;    // The pull up function is disabled GPH[10:0]
000094  e59f08a8          LDR      r0,|L1.2372|
000098  e5810078          STR      r0,[r1,#0x78]
;;;120        
;;;121    }
00009c  e12fff1e          BX       lr
;;;122    
                          ENDP

                  uart_change_baud PROC
;;;131    *********************************************************************************************/
;;;132    void uart_change_baud(int nChannel, int nBaud)
0000a0  e92d5ff0          PUSH     {r4-r12,lr}
;;;133    {
0000a4  e1a04000          MOV      r4,r0
0000a8  e1a09001          MOV      r9,r1
;;;134        if (nChannel == UART0)
0000ac  e3540000          CMP      r4,#0
0000b0  1a000010          BNE      |L1.248|
;;;135    	    rUBRDIV0=( (int)(PCLK/16./nBaud + 0.5) -1 );
0000b4  e1a00009          MOV      r0,r9
0000b8  ebfffffe          BL       __aeabi_i2d
0000bc  e1a05000          MOV      r5,r0
0000c0  e1a02005          MOV      r2,r5
0000c4  e1a03001          MOV      r3,r1
0000c8  e3a00000          MOV      r0,#0
0000cc  e59f1894          LDR      r1,|L1.2408|
0000d0  ebfffffe          BL       __aeabi_ddiv
0000d4  e1a07000          MOV      r7,r0
0000d8  e3a02000          MOV      r2,#0
0000dc  e59f3888          LDR      r3,|L1.2412|
0000e0  ebfffffe          BL       __aeabi_dadd
0000e4  e1a0a000          MOV      r10,r0
0000e8  ebfffffe          BL       __aeabi_d2iz
0000ec  e2400001          SUB      r0,r0,#1
0000f0  e3a01205          MOV      r1,#0x50000000
0000f4  e5810028          STR      r0,[r1,#0x28]
                  |L1.248|
;;;136        
;;;137        if (nChannel == UART1)
0000f8  e3540001          CMP      r4,#1
0000fc  1a00000c          BNE      |L1.308|
;;;138    	    rUBRDIV1=( (int)(PCLK/16./nBaud) -1 );
000100  e1a00009          MOV      r0,r9
000104  ebfffffe          BL       __aeabi_i2d
000108  e1a05000          MOV      r5,r0
00010c  e1a02005          MOV      r2,r5
000110  e1a03001          MOV      r3,r1
000114  e3a00000          MOV      r0,#0
000118  e59f1848          LDR      r1,|L1.2408|
00011c  ebfffffe          BL       __aeabi_ddiv
000120  e1a07000          MOV      r7,r0
000124  ebfffffe          BL       __aeabi_d2iz
000128  e2400001          SUB      r0,r0,#1
00012c  e59f183c          LDR      r1,|L1.2416|
000130  e5810028          STR      r0,[r1,#0x28]
                  |L1.308|
;;;139    
;;;140        if (nChannel == UART2)
000134  e35400bb          CMP      r4,#0xbb
000138  1a00000c          BNE      |L1.368|
;;;141    	    rUBRDIV2=( (int)(PCLK/16./nBaud) -1 );
00013c  e1a00009          MOV      r0,r9
000140  ebfffffe          BL       __aeabi_i2d
000144  e1a07000          MOV      r7,r0
000148  e1a02007          MOV      r2,r7
00014c  e1a03001          MOV      r3,r1
000150  e3a00000          MOV      r0,#0
000154  e59f180c          LDR      r1,|L1.2408|
000158  ebfffffe          BL       __aeabi_ddiv
00015c  e1a05000          MOV      r5,r0
000160  ebfffffe          BL       __aeabi_d2iz
000164  e2400001          SUB      r0,r0,#1
000168  e59f1804          LDR      r1,|L1.2420|
00016c  e5810028          STR      r0,[r1,#0x28]
                  |L1.368|
;;;142    }
000170  e8bd5ff0          POP      {r4-r12,lr}
000174  e12fff1e          BX       lr
;;;143    
                          ENDP

                  delay PROC
;;;561    *********************************************************************************************/
;;;562    void delay(int nTime)
000178  e92d4070          PUSH     {r4-r6,lr}
;;;563    {
00017c  e1a04000          MOV      r4,r0
;;;564          // time=0: adjust the Delay function by WatchDog timer.
;;;565          // time>0: the number of loop time
;;;566          // resolution of time is 100us.
;;;567        int i,adjust=0;
000180  e3a06000          MOV      r6,#0
;;;568        if(nTime==0)
000184  e3540000          CMP      r4,#0
000188  1a00000c          BNE      |L1.448|
;;;569        {
;;;570            nTime   = 200;
00018c  e3a040c8          MOV      r4,#0xc8
;;;571            adjust = 1;
000190  e3a06001          MOV      r6,#1
;;;572            delayLoopCount = 400;
000194  e3a00e19          MOV      r0,#0x190
000198  e59f17d8          LDR      r1,|L1.2424|
00019c  e5810000          STR      r0,[r1,#0]  ; delayLoopCount
;;;573    		//PCLK/1M,Watch-dog disable,1/64,interrupt disable,reset disable
;;;574            rWTCON = ((PCLK/1000000-1)<<8)|(2<<3); 
0001a0  e2800dbe          ADD      r0,r0,#0x2f80
0001a4  e3a01453          MOV      r1,#0x53000000
0001a8  e5810000          STR      r0,[r1,#0]
;;;575            rWTDAT = 0xffff;                             	//for first update
0001ac  e0660806          RSB      r0,r6,r6,LSL #16
0001b0  e5810004          STR      r0,[r1,#4]
;;;576            rWTCNT = 0xffff;                             	//resolution=64us @any PCLK 
0001b4  e5810008          STR      r0,[r1,#8]
;;;577            rWTCON = ((PCLK/1000000-1)<<8)|(2<<3)|(1<<5); 	//Watch-dog timer start
0001b8  e59f07bc          LDR      r0,|L1.2428|
0001bc  e5810000          STR      r0,[r1,#0]
                  |L1.448|
;;;578        }
;;;579        for(;nTime>0;nTime--)
0001c0  ea000007          B        |L1.484|
                  |L1.452|
;;;580            for(i=0;i<delayLoopCount;i++);
0001c4  e3a05000          MOV      r5,#0
0001c8  ea000000          B        |L1.464|
                  |L1.460|
0001cc  e2855001          ADD      r5,r5,#1
                  |L1.464|
0001d0  e59f07a0          LDR      r0,|L1.2424|
0001d4  e5900000          LDR      r0,[r0,#0]  ; delayLoopCount
0001d8  e1550000          CMP      r5,r0
0001dc  bafffffa          BLT      |L1.460|
0001e0  e2444001          SUB      r4,r4,#1              ;579
                  |L1.484|
0001e4  e3540000          CMP      r4,#0                 ;579
0001e8  cafffff5          BGT      |L1.452|
;;;581        if(adjust==1)
0001ec  e3560001          CMP      r6,#1
0001f0  1a00000b          BNE      |L1.548|
;;;582        {
;;;583            rWTCON = ((PCLK/1000000-1)<<8)|(2<<3);   		//Watch-dog timer stop
0001f4  e59f0784          LDR      r0,|L1.2432|
0001f8  e3a01453          MOV      r1,#0x53000000
0001fc  e5810000          STR      r0,[r1,#0]
;;;584            i = 0xffff - rWTCNT;                     		//1count->64us, 200*400 cycle runtime = 64*i us
000200  e3a00453          MOV      r0,#0x53000000
000204  e5900008          LDR      r0,[r0,#8]
000208  e59f1740          LDR      r1,|L1.2384|
00020c  e0415000          SUB      r5,r1,r0
;;;585            delayLoopCount = 8000000/(i*64);         		//200*400:64*i=1*x:100 -> x=80000*100/(64*i)   
000210  e1a01305          LSL      r1,r5,#6
000214  e59f0768          LDR      r0,|L1.2436|
000218  ebfffffe          BL       __aeabi_idivmod
00021c  e59f1754          LDR      r1,|L1.2424|
000220  e5810000          STR      r0,[r1,#0]  ; delayLoopCount
                  |L1.548|
;;;586        }
;;;587    }
000224  e8bd4070          POP      {r4-r6,lr}
000228  e12fff1e          BX       lr
;;;588    
                          ENDP

                  uart_init PROC
;;;153    *********************************************************************************************/
;;;154    void uart_init(int nMainClk, int nBaud, int nChannel)
00022c  e92d4ff0          PUSH     {r4-r11,lr}
;;;155    {
000230  e24dd01c          SUB      sp,sp,#0x1c
000234  e1a05000          MOV      r5,r0
000238  e1a06001          MOV      r6,r1
00023c  e1a09002          MOV      r9,r2
;;;156        int i;
;;;157        
;;;158        if(nMainClk == 0)
000240  e3550000          CMP      r5,#0
000244  1a000000          BNE      |L1.588|
;;;159        nMainClk    = PCLK;
000248  e59f5738          LDR      r5,|L1.2440|
                  |L1.588|
;;;160    
;;;161        switch (nChannel)
00024c  e3590000          CMP      r9,#0
000250  0a000004          BEQ      |L1.616|
000254  e3590001          CMP      r9,#1
000258  0a000025          BEQ      |L1.756|
00025c  e35900bb          CMP      r9,#0xbb
000260  1a00005f          BNE      |L1.996|
000264  ea000041          B        |L1.880|
                  |L1.616|
;;;162        {
;;;163        	case UART0: 
000268  e1a00000          MOV      r0,r0
;;;164    			rUFCON0 = 0x0;   //UART channel 0 FIFO control register, FIFO disable
00026c  e3a00000          MOV      r0,#0
000270  e3a01205          MOV      r1,#0x50000000
000274  e5810008          STR      r0,[r1,#8]
;;;165    			rUMCON0 = 0x0;   //UART chaneel 0 MODEM control register, AFC disable
000278  e581000c          STR      r0,[r1,#0xc]
;;;166    			rULCON0 = 0x3;   //Line control register : Normal,No parity,1 stop,8 bits
00027c  e3a00003          MOV      r0,#3
000280  e5810000          STR      r0,[r1,#0]
;;;167    	// [10]       [9]     [8]     [7]          [6]      [5]        [4]         [3:2]          [1:0]
;;;168    	// Clock Sel, Tx Int, Rx Int, Rx Time Out, Rx err,  Loop-back, Send break, Transmit Mode, Receive Mode
;;;169    	// 0          1       0,      0            1        0          0,          01             01
;;;170    	// PCLK       Level   Pulse   Disable      Generate Normal     Normal      Interrupt or Polling
;;;171    			rUCON0  = 0x245;								// Control register
000284  e59f0700          LDR      r0,|L1.2444|
000288  e5810004          STR      r0,[r1,#4]
;;;172    	//		rUBRDIV0=( (int)(nMainClk/16./nBaud) -1 );		// Baud rate divisior register 0
;;;173    			rUBRDIV0=( (int)(nMainClk/16./nBaud+0.5) -1 );	// Baud rate divisior register 0    
00028c  e1a00006          MOV      r0,r6
000290  ebfffffe          BL       __aeabi_i2d
000294  e1a0a000          MOV      r10,r0
000298  e1a0b001          MOV      r11,r1
00029c  e1a00005          MOV      r0,r5
0002a0  ebfffffe          BL       __aeabi_i2d
0002a4  e1a07000          MOV      r7,r0
0002a8  e3a02000          MOV      r2,#0
0002ac  e59f36dc          LDR      r3,|L1.2448|
0002b0  ebfffffe          BL       __aeabi_ddiv
0002b4  e1a0200a          MOV      r2,r10
0002b8  e1a0300b          MOV      r3,r11
0002bc  e88d0003          STM      sp,{r0,r1}
0002c0  ebfffffe          BL       __aeabi_ddiv
0002c4  e3a02000          MOV      r2,#0
0002c8  e58d0008          STR      r0,[sp,#8]
0002cc  e58d100c          STR      r1,[sp,#0xc]
0002d0  e59f3694          LDR      r3,|L1.2412|
0002d4  ebfffffe          BL       __aeabi_dadd
0002d8  e58d0010          STR      r0,[sp,#0x10]
0002dc  e58d1014          STR      r1,[sp,#0x14]
0002e0  ebfffffe          BL       __aeabi_d2iz
0002e4  e2400001          SUB      r0,r0,#1
0002e8  e3a01205          MOV      r1,#0x50000000
0002ec  e5810028          STR      r0,[r1,#0x28]
;;;174    			break;
0002f0  ea00003d          B        |L1.1004|
                  |L1.756|
;;;175    			
;;;176    		case UART1: 
0002f4  e1a00000          MOV      r0,r0
;;;177    			rUFCON1 = 0x0;   //UART channel 1 FIFO control register, FIFO disable
0002f8  e3a00000          MOV      r0,#0
0002fc  e59f166c          LDR      r1,|L1.2416|
000300  e5810008          STR      r0,[r1,#8]
;;;178    			rUMCON1 = 0x0;   //UART chaneel 1 MODEM control register, AFC disable
000304  e581000c          STR      r0,[r1,#0xc]
;;;179    			rULCON1 = 0x3;
000308  e3a00003          MOV      r0,#3
00030c  e5810000          STR      r0,[r1,#0]
;;;180    			rUCON1  = 0x245;
000310  e59f0674          LDR      r0,|L1.2444|
000314  e5810004          STR      r0,[r1,#4]
;;;181    			rUBRDIV1=( (int)(nMainClk/16./nBaud) -1 );
000318  e1a00006          MOV      r0,r6
00031c  ebfffffe          BL       __aeabi_i2d
000320  e1a07000          MOV      r7,r0
000324  e1a08001          MOV      r8,r1
000328  e1a00005          MOV      r0,r5
00032c  ebfffffe          BL       __aeabi_i2d
000330  e1a0a000          MOV      r10,r0
000334  e3a02000          MOV      r2,#0
000338  e59f3650          LDR      r3,|L1.2448|
00033c  ebfffffe          BL       __aeabi_ddiv
000340  e1a02007          MOV      r2,r7
000344  e1a03008          MOV      r3,r8
000348  e58d0008          STR      r0,[sp,#8]
00034c  e58d100c          STR      r1,[sp,#0xc]
000350  ebfffffe          BL       __aeabi_ddiv
000354  e58d0010          STR      r0,[sp,#0x10]
000358  e58d1014          STR      r1,[sp,#0x14]
00035c  ebfffffe          BL       __aeabi_d2iz
000360  e2400001          SUB      r0,r0,#1
000364  e59f1604          LDR      r1,|L1.2416|
000368  e5810028          STR      r0,[r1,#0x28]
;;;182    			break;
00036c  ea00001e          B        |L1.1004|
                  |L1.880|
;;;183    			
;;;184        	case UART2: 
000370  e1a00000          MOV      r0,r0
;;;185    			rULCON2 = 0x3;
000374  e3a00003          MOV      r0,#3
000378  e59f15f4          LDR      r1,|L1.2420|
00037c  e5810000          STR      r0,[r1,#0]
;;;186    			rUCON2  = 0x245;
000380  e59f0604          LDR      r0,|L1.2444|
000384  e5810004          STR      r0,[r1,#4]
;;;187    			rUBRDIV2=( (int)(nMainClk/16./nBaud) -1 );    
000388  e1a00006          MOV      r0,r6
00038c  ebfffffe          BL       __aeabi_i2d
000390  e58d0008          STR      r0,[sp,#8]
000394  e58d100c          STR      r1,[sp,#0xc]
000398  e1a00005          MOV      r0,r5
00039c  ebfffffe          BL       __aeabi_i2d
0003a0  e1a07000          MOV      r7,r0
0003a4  e3a02000          MOV      r2,#0
0003a8  e59f35e0          LDR      r3,|L1.2448|
0003ac  ebfffffe          BL       __aeabi_ddiv
0003b0  e1a0a000          MOV      r10,r0
0003b4  e59d2008          LDR      r2,[sp,#8]
0003b8  e59d300c          LDR      r3,[sp,#0xc]
0003bc  ebfffffe          BL       __aeabi_ddiv
0003c0  e58d0010          STR      r0,[sp,#0x10]
0003c4  e58d1014          STR      r1,[sp,#0x14]
0003c8  ebfffffe          BL       __aeabi_d2iz
0003cc  e2400001          SUB      r0,r0,#1
0003d0  e59f159c          LDR      r1,|L1.2420|
0003d4  e5810028          STR      r0,[r1,#0x28]
;;;188    			rUFCON2 = 0x0;   //UART channel 2 FIFO control register, FIFO disable
0003d8  e3a00000          MOV      r0,#0
0003dc  e5810008          STR      r0,[r1,#8]
;;;189    			break;
0003e0  ea000001          B        |L1.1004|
                  |L1.996|
;;;190    			
;;;191    		default:
0003e4  e1a00000          MOV      r0,r0
;;;192    			break;
0003e8  e1a00000          MOV      r0,r0
                  |L1.1004|
0003ec  e1a00000          MOV      r0,r0                 ;174
;;;193    	}
;;;194    
;;;195        for(i=0;i<100;i++);
0003f0  e3a04000          MOV      r4,#0
0003f4  ea000000          B        |L1.1020|
                  |L1.1016|
0003f8  e2844001          ADD      r4,r4,#1
                  |L1.1020|
0003fc  e3540064          CMP      r4,#0x64
000400  bafffffc          BLT      |L1.1016|
;;;196        delay(400);
000404  e3a00e19          MOV      r0,#0x190
000408  ebfffffe          BL       delay
;;;197    }
00040c  e28dd01c          ADD      sp,sp,#0x1c
000410  e8bd4ff0          POP      {r4-r11,lr}
000414  e12fff1e          BX       lr
;;;198    
                          ENDP

                  uart_select PROC
;;;206    *********************************************************************************************/
;;;207    void uart_select(int nChannel)
000418  e59f1574          LDR      r1,|L1.2452|
;;;208    {
;;;209        f_nWhichUart=nChannel;
00041c  e5810000          STR      r0,[r1,#0]  ; f_nWhichUart
;;;210    }
000420  e12fff1e          BX       lr
;;;211    
                          ENDP

                  uart_txempty PROC
;;;219    *********************************************************************************************/
;;;220    void uart_txempty(int nChannel)
000424  e3500000          CMP      r0,#0
;;;221    {
;;;222        if(nChannel==0)
000428  1a000005          BNE      |L1.1092|
;;;223            while(!(rUTRSTAT0 & 0x4)); //Wait until tx shifter is empty.
00042c  e1a00000          MOV      r0,r0
                  |L1.1072|
000430  e3a01205          MOV      r1,#0x50000000
000434  e5911010          LDR      r1,[r1,#0x10]
000438  e3110004          TST      r1,#4
00043c  0afffffb          BEQ      |L1.1072|
000440  ea00000e          B        |L1.1152|
                  |L1.1092|
;;;224              
;;;225        else if(nChannel==1)
000444  e3500001          CMP      r0,#1
000448  1a000005          BNE      |L1.1124|
;;;226            while(!(rUTRSTAT1 & 0x4)); //Wait until tx shifter is empty.
00044c  e1a00000          MOV      r0,r0
                  |L1.1104|
000450  e59f1518          LDR      r1,|L1.2416|
000454  e5911010          LDR      r1,[r1,#0x10]
000458  e3110004          TST      r1,#4
00045c  0afffffb          BEQ      |L1.1104|
000460  ea000006          B        |L1.1152|
                  |L1.1124|
;;;227            
;;;228        else if(nChannel==2)
000464  e3500002          CMP      r0,#2
000468  1a000004          BNE      |L1.1152|
;;;229            while(!(rUTRSTAT2 & 0x4)); //Wait until tx shifter is empty.
00046c  e1a00000          MOV      r0,r0
                  |L1.1136|
000470  e59f14fc          LDR      r1,|L1.2420|
000474  e5911010          LDR      r1,[r1,#0x10]
000478  e3110004          TST      r1,#4
00047c  0afffffb          BEQ      |L1.1136|
                  |L1.1152|
;;;230    }
000480  e12fff1e          BX       lr
;;;231    
                          ENDP

                  uart_getch PROC
;;;239    *********************************************************************************************/
;;;240    char uart_getch(void)
000484  e59f0508          LDR      r0,|L1.2452|
;;;241    {
;;;242        if(f_nWhichUart==0)
000488  e5900000          LDR      r0,[r0,#0]  ; f_nWhichUart
00048c  e3500000          CMP      r0,#0
000490  1a000007          BNE      |L1.1204|
;;;243        {       
;;;244            while(!(rUTRSTAT0 & 0x1)); //Receive data ready
000494  e1a00000          MOV      r0,r0
                  |L1.1176|
000498  e3a00205          MOV      r0,#0x50000000
00049c  e5900010          LDR      r0,[r0,#0x10]
0004a0  e3100001          TST      r0,#1
0004a4  0afffffb          BEQ      |L1.1176|
;;;245            return RdURXH0();
0004a8  e3a00205          MOV      r0,#0x50000000
0004ac  e5d00024          LDRB     r0,[r0,#0x24]
                  |L1.1200|
;;;246        }
;;;247        else if(f_nWhichUart==1)
;;;248        {       
;;;249            while(!(rUTRSTAT1 & 0x1)); //Receive data ready
;;;250            return RdURXH1();
;;;251        }
;;;252        else if(f_nWhichUart==2)
;;;253        {
;;;254            while(!(rUTRSTAT2 & 0x1)); //Receive data ready
;;;255            return RdURXH2();
;;;256        }
;;;257    	return NULL;
;;;258    }
0004b0  e12fff1e          BX       lr
                  |L1.1204|
0004b4  e59f04d8          LDR      r0,|L1.2452|
0004b8  e5900000          LDR      r0,[r0,#0]            ;247  ; f_nWhichUart
0004bc  e3500001          CMP      r0,#1                 ;247
0004c0  1a000007          BNE      |L1.1252|
0004c4  e1a00000          MOV      r0,r0                 ;249
                  |L1.1224|
0004c8  e59f04a0          LDR      r0,|L1.2416|
0004cc  e5900010          LDR      r0,[r0,#0x10]         ;249
0004d0  e3100001          TST      r0,#1                 ;249
0004d4  0afffffb          BEQ      |L1.1224|
0004d8  e59f0490          LDR      r0,|L1.2416|
0004dc  e5d00024          LDRB     r0,[r0,#0x24]         ;250
0004e0  eafffff2          B        |L1.1200|
                  |L1.1252|
0004e4  e59f04a8          LDR      r0,|L1.2452|
0004e8  e5900000          LDR      r0,[r0,#0]            ;252  ; f_nWhichUart
0004ec  e3500002          CMP      r0,#2                 ;252
0004f0  1a000007          BNE      |L1.1300|
0004f4  e1a00000          MOV      r0,r0                 ;254
                  |L1.1272|
0004f8  e59f0474          LDR      r0,|L1.2420|
0004fc  e5900010          LDR      r0,[r0,#0x10]         ;254
000500  e3100001          TST      r0,#1                 ;254
000504  0afffffb          BEQ      |L1.1272|
000508  e59f0464          LDR      r0,|L1.2420|
00050c  e5d00024          LDRB     r0,[r0,#0x24]         ;255
000510  eaffffe6          B        |L1.1200|
                  |L1.1300|
000514  e3a00000          MOV      r0,#0                 ;257
000518  eaffffe4          B        |L1.1200|
;;;259    
                          ENDP

                  uart_getkey PROC
;;;267    *********************************************************************************************/
;;;268    char uart_getkey(void)
00051c  e59f0470          LDR      r0,|L1.2452|
;;;269    {
;;;270        if(f_nWhichUart==0)
000520  e5900000          LDR      r0,[r0,#0]  ; f_nWhichUart
000524  e3500000          CMP      r0,#0
000528  1a000008          BNE      |L1.1360|
;;;271        {       
;;;272            if(rUTRSTAT0 & 0x1)    //Receive data ready
00052c  e3a00205          MOV      r0,#0x50000000
000530  e5900010          LDR      r0,[r0,#0x10]
000534  e3100001          TST      r0,#1
000538  0a000002          BEQ      |L1.1352|
;;;273                return RdURXH0();
00053c  e3a00205          MOV      r0,#0x50000000
000540  e5d00024          LDRB     r0,[r0,#0x24]
                  |L1.1348|
;;;274            else
;;;275                return 0;
;;;276        }
;;;277        else if(f_nWhichUart==1)
;;;278        {
;;;279            if(rUTRSTAT1 & 0x1)    //Receive data ready
;;;280                return RdURXH1();
;;;281            else
;;;282                return 0;
;;;283        }
;;;284        else if(f_nWhichUart==2)
;;;285        {       
;;;286            if(rUTRSTAT2 & 0x1)    //Receive data ready
;;;287                return RdURXH2();
;;;288            else
;;;289                return 0;
;;;290        }    
;;;291    	return NULL;
;;;292    }
000544  e12fff1e          BX       lr
                  |L1.1352|
000548  e3a00000          MOV      r0,#0                 ;275
00054c  eafffffc          B        |L1.1348|
                  |L1.1360|
000550  e59f043c          LDR      r0,|L1.2452|
000554  e5900000          LDR      r0,[r0,#0]            ;277  ; f_nWhichUart
000558  e3500001          CMP      r0,#1                 ;277
00055c  1a000008          BNE      |L1.1412|
000560  e59f0408          LDR      r0,|L1.2416|
000564  e5900010          LDR      r0,[r0,#0x10]         ;279
000568  e3100001          TST      r0,#1                 ;279
00056c  0a000002          BEQ      |L1.1404|
000570  e59f03f8          LDR      r0,|L1.2416|
000574  e5d00024          LDRB     r0,[r0,#0x24]         ;280
000578  eafffff1          B        |L1.1348|
                  |L1.1404|
00057c  e3a00000          MOV      r0,#0                 ;282
000580  eaffffef          B        |L1.1348|
                  |L1.1412|
000584  e59f0408          LDR      r0,|L1.2452|
000588  e5900000          LDR      r0,[r0,#0]            ;284  ; f_nWhichUart
00058c  e3500002          CMP      r0,#2                 ;284
000590  1a000008          BNE      |L1.1464|
000594  e59f03d8          LDR      r0,|L1.2420|
000598  e5900010          LDR      r0,[r0,#0x10]         ;286
00059c  e3100001          TST      r0,#1                 ;286
0005a0  0a000002          BEQ      |L1.1456|
0005a4  e59f03c8          LDR      r0,|L1.2420|
0005a8  e5d00024          LDRB     r0,[r0,#0x24]         ;287
0005ac  eaffffe4          B        |L1.1348|
                  |L1.1456|
0005b0  e3a00000          MOV      r0,#0                 ;289
0005b4  eaffffe2          B        |L1.1348|
                  |L1.1464|
0005b8  e3a00000          MOV      r0,#0                 ;291
0005bc  eaffffe0          B        |L1.1348|
;;;293    
                          ENDP

                  uart_sendbyte PROC
;;;403    *********************************************************************************************/
;;;404    void uart_sendbyte(int nData)
0005c0  e92d4010          PUSH     {r4,lr}
;;;405    {
0005c4  e1a04000          MOV      r4,r0
;;;406        if(f_nWhichUart==0)
0005c8  e59f03c4          LDR      r0,|L1.2452|
0005cc  e5900000          LDR      r0,[r0,#0]  ; f_nWhichUart
0005d0  e3500000          CMP      r0,#0
0005d4  1a000015          BNE      |L1.1584|
;;;407        {
;;;408            if(nData=='\n')
0005d8  e354000a          CMP      r4,#0xa
0005dc  1a000009          BNE      |L1.1544|
;;;409            {
;;;410                while(!(rUTRSTAT0 & 0x2));
0005e0  e1a00000          MOV      r0,r0
                  |L1.1508|
0005e4  e3a00205          MOV      r0,#0x50000000
0005e8  e5900010          LDR      r0,[r0,#0x10]
0005ec  e3100002          TST      r0,#2
0005f0  0afffffb          BEQ      |L1.1508|
;;;411                delay(10);					//because the slow response of hyper_terminal 
0005f4  e3a0000a          MOV      r0,#0xa
0005f8  ebfffffe          BL       delay
;;;412                WrUTXH0('\r');
0005fc  e3a0000d          MOV      r0,#0xd
000600  e3a01205          MOV      r1,#0x50000000
000604  e5c10020          STRB     r0,[r1,#0x20]
                  |L1.1544|
;;;413            }
;;;414            while(!(rUTRSTAT0 & 0x2));		//Wait until THR is empty.
000608  e1a00000          MOV      r0,r0
                  |L1.1548|
00060c  e3a00205          MOV      r0,#0x50000000
000610  e5900010          LDR      r0,[r0,#0x10]
000614  e3100002          TST      r0,#2
000618  0afffffb          BEQ      |L1.1548|
;;;415            delay(10);
00061c  e3a0000a          MOV      r0,#0xa
000620  ebfffffe          BL       delay
;;;416            WrUTXH0(nData);
000624  e3a01205          MOV      r1,#0x50000000
000628  e5c14020          STRB     r4,[r1,#0x20]
00062c  ea000032          B        |L1.1788|
                  |L1.1584|
;;;417        }
;;;418        else if(f_nWhichUart==1)
000630  e59f035c          LDR      r0,|L1.2452|
000634  e5900000          LDR      r0,[r0,#0]  ; f_nWhichUart
000638  e3500001          CMP      r0,#1
00063c  1a000015          BNE      |L1.1688|
;;;419        {
;;;420            if(nData=='\n')
000640  e354000a          CMP      r4,#0xa
000644  1a000009          BNE      |L1.1648|
;;;421            {
;;;422                while(!(rUTRSTAT1 & 0x2));
000648  e1a00000          MOV      r0,r0
                  |L1.1612|
00064c  e59f031c          LDR      r0,|L1.2416|
000650  e5900010          LDR      r0,[r0,#0x10]
000654  e3100002          TST      r0,#2
000658  0afffffb          BEQ      |L1.1612|
;;;423                delay(10);					//because the slow response of hyper_terminal 
00065c  e3a0000a          MOV      r0,#0xa
000660  ebfffffe          BL       delay
;;;424                rUTXH1 = '\r';
000664  e3a0000d          MOV      r0,#0xd
000668  e59f1300          LDR      r1,|L1.2416|
00066c  e5c10020          STRB     r0,[r1,#0x20]
                  |L1.1648|
;;;425            }
;;;426            while(!(rUTRSTAT1 & 0x2));		//Wait until THR is empty.
000670  e1a00000          MOV      r0,r0
                  |L1.1652|
000674  e59f02f4          LDR      r0,|L1.2416|
000678  e5900010          LDR      r0,[r0,#0x10]
00067c  e3100002          TST      r0,#2
000680  0afffffb          BEQ      |L1.1652|
;;;427            delay(10);
000684  e3a0000a          MOV      r0,#0xa
000688  ebfffffe          BL       delay
;;;428            rUTXH1 = nData;
00068c  e59f12dc          LDR      r1,|L1.2416|
000690  e5c14020          STRB     r4,[r1,#0x20]
000694  ea000018          B        |L1.1788|
                  |L1.1688|
;;;429        }   
;;;430        else if(f_nWhichUart==2)
000698  e59f02f4          LDR      r0,|L1.2452|
00069c  e5900000          LDR      r0,[r0,#0]  ; f_nWhichUart
0006a0  e3500002          CMP      r0,#2
0006a4  1a000014          BNE      |L1.1788|
;;;431        {
;;;432            if(nData=='\n')
0006a8  e354000a          CMP      r4,#0xa
0006ac  1a000009          BNE      |L1.1752|
;;;433            {
;;;434                while(!(rUTRSTAT2 & 0x2));
0006b0  e1a00000          MOV      r0,r0
                  |L1.1716|
0006b4  e59f02b8          LDR      r0,|L1.2420|
0006b8  e5900010          LDR      r0,[r0,#0x10]
0006bc  e3100002          TST      r0,#2
0006c0  0afffffb          BEQ      |L1.1716|
;;;435                delay(10);					//because the slow response of hyper_terminal 
0006c4  e3a0000a          MOV      r0,#0xa
0006c8  ebfffffe          BL       delay
;;;436                rUTXH2 = '\r';
0006cc  e3a0000d          MOV      r0,#0xd
0006d0  e59f129c          LDR      r1,|L1.2420|
0006d4  e5c10020          STRB     r0,[r1,#0x20]
                  |L1.1752|
;;;437            }
;;;438            while(!(rUTRSTAT2 & 0x2));		//Wait until THR is empty.
0006d8  e1a00000          MOV      r0,r0
                  |L1.1756|
0006dc  e59f0290          LDR      r0,|L1.2420|
0006e0  e5900010          LDR      r0,[r0,#0x10]
0006e4  e3100002          TST      r0,#2
0006e8  0afffffb          BEQ      |L1.1756|
;;;439            delay(10);
0006ec  e3a0000a          MOV      r0,#0xa
0006f0  ebfffffe          BL       delay
;;;440            rUTXH2 = nData;
0006f4  e59f1278          LDR      r1,|L1.2420|
0006f8  e5c14020          STRB     r4,[r1,#0x20]
                  |L1.1788|
;;;441        }       
;;;442    }               
0006fc  e8bd4010          POP      {r4,lr}
000700  e12fff1e          BX       lr
;;;443    
                          ENDP

                  uart_sendstring PROC
;;;451    *********************************************************************************************/
;;;452    void uart_sendstring(char *pString)
000704  e92d4010          PUSH     {r4,lr}
;;;453    {
000708  e1a04000          MOV      r4,r0
;;;454        while(*pString)
00070c  ea000001          B        |L1.1816|
                  |L1.1808|
;;;455            uart_sendbyte(*pString++);
000710  e4d40001          LDRB     r0,[r4],#1
000714  ebfffffe          BL       uart_sendbyte
                  |L1.1816|
000718  e5d40000          LDRB     r0,[r4,#0]            ;454
00071c  e3500000          CMP      r0,#0                 ;454
000720  1afffffa          BNE      |L1.1808|
;;;456    }
000724  e8bd4010          POP      {r4,lr}
000728  e12fff1e          BX       lr
;;;457    
                          ENDP

                  uart_printf PROC
;;;465    *********************************************************************************************/
;;;466    void uart_printf(char *fmt,...)
00072c  e92d000f          PUSH     {r0-r3}
;;;467    {
000730  e52de004          PUSH     {lr}
000734  e24ddf41          SUB      sp,sp,#0x104
;;;468        va_list ap;
;;;469        char pString[256];
;;;470    
;;;471        va_start(ap,fmt);
000738  e28d0f43          ADD      r0,sp,#0x10c
00073c  e58d0100          STR      r0,[sp,#0x100]
;;;472        vsprintf(pString,fmt,ap);
000740  e59d1108          LDR      r1,[sp,#0x108]
000744  e59d2100          LDR      r2,[sp,#0x100]
000748  e1a0000d          MOV      r0,sp
00074c  ebfffffe          BL       __c89vsprintf
;;;473        uart_sendstring(pString);
000750  e1a0000d          MOV      r0,sp
000754  ebfffffe          BL       uart_sendstring
;;;474        va_end(ap);
000758  e3a00000          MOV      r0,#0
00075c  e58d0100          STR      r0,[sp,#0x100]
;;;475    }
000760  e28ddf41          ADD      sp,sp,#0x104
000764  e49de014          LDR      lr,[sp],#0x14
000768  e12fff1e          BX       lr
;;;476    
                          ENDP

                  uart_getstring PROC
;;;301    *********************************************************************************************/
;;;302    void uart_getstring(char *pString)
00076c  e92d4070          PUSH     {r4-r6,lr}
;;;303    {
000770  e1a04000          MOV      r4,r0
;;;304        char *string2 = pString;
000774  e1a06004          MOV      r6,r4
;;;305        char c;
;;;306        while((c = uart_getch())!='\r')
000778  ea00000a          B        |L1.1960|
                  |L1.1916|
;;;307        {
;;;308            if(c=='\b')
00077c  e3550008          CMP      r5,#8
000780  1a000005          BNE      |L1.1948|
;;;309            {
;;;310                if( (int)string2 < (int)pString )
000784  e1560004          CMP      r6,r4
000788  aa000006          BGE      |L1.1960|
;;;311                {
;;;312                    uart_printf("\b \b");
00078c  e28f0f81          ADR      r0,|L1.2456|
000790  ebfffffe          BL       uart_printf
;;;313                    pString--;
000794  e2444001          SUB      r4,r4,#1
000798  ea000002          B        |L1.1960|
                  |L1.1948|
;;;314                }
;;;315            }
;;;316            else 
;;;317            {
;;;318                *pString++ = c;
00079c  e4c45001          STRB     r5,[r4],#1
;;;319                uart_sendbyte(c);
0007a0  e1a00005          MOV      r0,r5
0007a4  ebfffffe          BL       uart_sendbyte
                  |L1.1960|
0007a8  ebfffffe          BL       uart_getch
0007ac  e1a05000          MOV      r5,r0                 ;306
0007b0  e350000d          CMP      r0,#0xd               ;306
0007b4  1afffff0          BNE      |L1.1916|
;;;320            }
;;;321        }
;;;322        *pString='\0';
0007b8  e3a00000          MOV      r0,#0
0007bc  e5c40000          STRB     r0,[r4,#0]
;;;323        uart_sendbyte('\n');
0007c0  e3a0000a          MOV      r0,#0xa
0007c4  ebfffffe          BL       uart_sendbyte
;;;324    }
0007c8  e8bd4070          POP      {r4-r6,lr}
0007cc  e12fff1e          BX       lr
;;;325    
                          ENDP

                  uart_getintnum PROC
;;;335    *********************************************************************************************/
;;;336    int uart_getintnum(void)
0007d0  e92d43f0          PUSH     {r4-r9,lr}
;;;337    {
0007d4  e24dd024          SUB      sp,sp,#0x24
;;;338        char str[30];
;;;339        char *pString = str;
0007d8  e28d4004          ADD      r4,sp,#4
;;;340        int base     = 10;
0007dc  e3a0900a          MOV      r9,#0xa
;;;341        int minus    = 0;
0007e0  e3a08000          MOV      r8,#0
;;;342        int nResult   = 0;
0007e4  e3a07000          MOV      r7,#0
;;;343        int lastIndex;    
;;;344        int i;
;;;345        
;;;346        uart_getstring(pString);
0007e8  e1a00004          MOV      r0,r4
0007ec  ebfffffe          BL       uart_getstring
;;;347        
;;;348        if(pString[0]=='-')
0007f0  e5d40000          LDRB     r0,[r4,#0]
0007f4  e350002d          CMP      r0,#0x2d
0007f8  1a000001          BNE      |L1.2052|
;;;349        {
;;;350            minus = 1;
0007fc  e3a08001          MOV      r8,#1
;;;351            pString++;
000800  e2844001          ADD      r4,r4,#1
                  |L1.2052|
;;;352        }
;;;353        
;;;354        if(pString[0]=='0' && (pString[1]=='x' || pString[1]=='X'))
000804  e5d40000          LDRB     r0,[r4,#0]
000808  e3500030          CMP      r0,#0x30
00080c  1a000007          BNE      |L1.2096|
000810  e5d40001          LDRB     r0,[r4,#1]
000814  e3500078          CMP      r0,#0x78
000818  0a000002          BEQ      |L1.2088|
00081c  e5d40001          LDRB     r0,[r4,#1]
000820  e3500058          CMP      r0,#0x58
000824  1a000001          BNE      |L1.2096|
                  |L1.2088|
;;;355        {
;;;356            base    = 16;
000828  e3a09010          MOV      r9,#0x10
;;;357            pString += 2;
00082c  e2844002          ADD      r4,r4,#2
                  |L1.2096|
;;;358        }
;;;359        
;;;360        lastIndex = strlen(pString) - 1;
000830  e1a00004          MOV      r0,r4
000834  ebfffffe          BL       strlen
000838  e2406001          SUB      r6,r0,#1
;;;361        
;;;362        if(lastIndex<0)
00083c  e3560000          CMP      r6,#0
000840  aa000003          BGE      |L1.2132|
;;;363            return -1;
000844  e3e00000          MVN      r0,#0
                  |L1.2120|
000848  e28dd024          ADD      sp,sp,#0x24
00084c  e8bd43f0          POP      {r4-r9,lr}
;;;364        
;;;365        if(pString[lastIndex]=='h' || pString[lastIndex]=='H' )
;;;366        {
;;;367            base = 16;
;;;368            pString[lastIndex] = 0;
;;;369            lastIndex--;
;;;370        }
;;;371    
;;;372        if(base==10)
;;;373        {
;;;374            nResult = atoi(pString);
;;;375            nResult = minus ? (-1*nResult):nResult;
;;;376        }
;;;377        else
;;;378        {
;;;379            for(i=0;i<=lastIndex;i++)
;;;380            {
;;;381                if(isalpha(pString[i]))
;;;382                {
;;;383                    if(isupper(pString[i]))
;;;384                        nResult = (nResult<<4) + pString[i] - 'A' + 10;
;;;385                    else
;;;386                        nResult = (nResult<<4) + pString[i] - 'a' + 10;
;;;387                }
;;;388                else
;;;389                    nResult = (nResult<<4) + pString[i] - '0';
;;;390            }
;;;391            nResult = minus ? (-1*nResult):nResult;
;;;392        }
;;;393        return nResult;
;;;394    }
000850  e12fff1e          BX       lr
                  |L1.2132|
000854  e7d40006          LDRB     r0,[r4,r6]            ;365
000858  e3500068          CMP      r0,#0x68              ;365
00085c  0a000002          BEQ      |L1.2156|
000860  e7d40006          LDRB     r0,[r4,r6]            ;365
000864  e3500048          CMP      r0,#0x48              ;365
000868  1a000003          BNE      |L1.2172|
                  |L1.2156|
00086c  e3a09010          MOV      r9,#0x10              ;367
000870  e3a00000          MOV      r0,#0                 ;368
000874  e7c40006          STRB     r0,[r4,r6]            ;368
000878  e2466001          SUB      r6,r6,#1              ;369
                  |L1.2172|
00087c  e359000a          CMP      r9,#0xa               ;372
000880  1a000009          BNE      |L1.2220|
000884  e1a00004          MOV      r0,r4                 ;374
000888  ebfffffe          BL       atoi
00088c  e1a07000          MOV      r7,r0                 ;374
000890  e3580000          CMP      r8,#0                 ;375
000894  0a000001          BEQ      |L1.2208|
000898  e2670000          RSB      r0,r7,#0              ;375
00089c  ea000000          B        |L1.2212|
                  |L1.2208|
0008a0  e1a00007          MOV      r0,r7                 ;375
                  |L1.2212|
0008a4  e1a07000          MOV      r7,r0                 ;375
0008a8  ea000021          B        |L1.2356|
                  |L1.2220|
0008ac  e3a05000          MOV      r5,#0                 ;379
0008b0  ea000017          B        |L1.2324|
                  |L1.2228|
0008b4  ebfffffe          BL       __rt_ctype_table
0008b8  e5900000          LDR      r0,[r0,#0]            ;381
0008bc  e7d41005          LDRB     r1,[r4,r5]            ;381
0008c0  e7d00001          LDRB     r0,[r0,r1]            ;381
0008c4  e3100098          TST      r0,#0x98              ;381
0008c8  0a00000d          BEQ      |L1.2308|
0008cc  ebfffffe          BL       __rt_ctype_table
0008d0  e5900000          LDR      r0,[r0,#0]            ;383
0008d4  e7d41005          LDRB     r1,[r4,r5]            ;383
0008d8  e7d00001          LDRB     r0,[r0,r1]            ;383
0008dc  e3100010          TST      r0,#0x10              ;383
0008e0  0a000003          BEQ      |L1.2292|
0008e4  e7d40005          LDRB     r0,[r4,r5]            ;384
0008e8  e0800207          ADD      r0,r0,r7,LSL #4       ;384
0008ec  e2407037          SUB      r7,r0,#0x37           ;384
0008f0  ea000006          B        |L1.2320|
                  |L1.2292|
0008f4  e7d40005          LDRB     r0,[r4,r5]            ;386
0008f8  e0800207          ADD      r0,r0,r7,LSL #4       ;386
0008fc  e2407057          SUB      r7,r0,#0x57           ;386
000900  ea000002          B        |L1.2320|
                  |L1.2308|
000904  e7d40005          LDRB     r0,[r4,r5]            ;389
000908  e0800207          ADD      r0,r0,r7,LSL #4       ;389
00090c  e2407030          SUB      r7,r0,#0x30           ;389
                  |L1.2320|
000910  e2855001          ADD      r5,r5,#1              ;379
                  |L1.2324|
000914  e1550006          CMP      r5,r6                 ;379
000918  daffffe5          BLE      |L1.2228|
00091c  e3580000          CMP      r8,#0                 ;391
000920  0a000001          BEQ      |L1.2348|
000924  e2670000          RSB      r0,r7,#0              ;391
000928  ea000000          B        |L1.2352|
                  |L1.2348|
00092c  e1a00007          MOV      r0,r7                 ;391
                  |L1.2352|
000930  e1a07000          MOV      r7,r0                 ;391
                  |L1.2356|
000934  e1a00007          MOV      r0,r7                 ;393
000938  eaffffc2          B        |L1.2120|
                  |L1.2364|
                          DCD      0x005fbfff
                  |L1.2368|
                          DCD      0x00155559
                  |L1.2372|
                          DCD      0x000007ff
                  |L1.2376|
                          DCD      0xaaaa55aa
                  |L1.2380|
                          DCD      0xaaaaaaaa
                  |L1.2384|
                          DCD      0x0000ffff
                  |L1.2388|
                          DCD      0xa6aaaaaa
                  |L1.2392|
                          DCD      0x000055aa
                  |L1.2396|
                          DCD      0xff4af7b9
                  |L1.2400|
                          DCD      0x0000ffcf
                  |L1.2404|
                          DCD      0x002aaaaa
                  |L1.2408|
                          DCD      0x41482cf7
                  |L1.2412|
                          DCD      0x3fe00000
                  |L1.2416|
                          DCD      0x50004000
                  |L1.2420|
                          DCD      0x50008000
                  |L1.2424|
                          DCD      delayLoopCount
                  |L1.2428|
                          DCD      0x00003130
                  |L1.2432|
                          DCD      0x00003110
                  |L1.2436|
                          DCD      0x007a1200
                  |L1.2440|
                          DCD      0x03059ee0
                  |L1.2444|
                          DCD      0x00000245
                  |L1.2448|
                          DCD      0x40300000
                  |L1.2452|
                          DCD      f_nWhichUart
                  |L1.2456|
000998  08200800          DCB      "\b \b",0
                          ENDP

                  timer_start PROC
;;;484    *********************************************************************************************/
;;;485    void timer_start(int divider)  
00099c  e3a01c31          MOV      r1,#0x3100
;;;486    {
;;;487        rWTCON = ((PCLK/1000000-1)<<8)|(divider<<3); //Watch-dog timer control register
0009a0  e1811180          ORR      r1,r1,r0,LSL #3
0009a4  e3a02453          MOV      r2,#0x53000000
0009a8  e5821000          STR      r1,[r2,#0]
;;;488        rWTDAT = 0xffff;							 //Watch-dog timer data register
0009ac  e51f1064          LDR      r1,|L1.2384|
0009b0  e5821004          STR      r1,[r2,#4]
;;;489        rWTCNT = 0xffff;							 //Watch-dog count register
0009b4  e5821008          STR      r1,[r2,#8]
;;;490    
;;;491        rWTCON = rWTCON | (1<<5) | ~(1<<2);  		 //May 06, 2002 SOP
0009b8  e3a01453          MOV      r1,#0x53000000
0009bc  e5911000          LDR      r1,[r1,#0]
0009c0  e3811020          ORR      r1,r1,#0x20
0009c4  e3e02004          MVN      r2,#4
0009c8  e1811002          ORR      r1,r1,r2
0009cc  e3a02453          MOV      r2,#0x53000000
0009d0  e5821000          STR      r1,[r2,#0]
;;;492    }
0009d4  e12fff1e          BX       lr
;;;493    
                          ENDP

                  timer_stop PROC
;;;501    *********************************************************************************************/
;;;502    int timer_stop(void)
0009d8  e3a00c31          MOV      r0,#0x3100
;;;503    {
;;;504        rWTCON = ((PCLK/1000000-1)<<8);
0009dc  e3a01453          MOV      r1,#0x53000000
0009e0  e5810000          STR      r0,[r1,#0]
;;;505        return (0xffff - rWTCNT);
0009e4  e3a00453          MOV      r0,#0x53000000
0009e8  e5900008          LDR      r0,[r0,#8]
0009ec  e51f10a4          LDR      r1,|L1.2384|
0009f0  e0410000          SUB      r0,r1,r0
;;;506    }
0009f4  e12fff1e          BX       lr
;;;507    
                          ENDP

                  change_value_MPLL PROC
;;;515    *********************************************************************************************/
;;;516    void change_value_MPLL(int nMdiv,int nPdiv,int nSdiv)
0009f8  e1a03600          LSL      r3,r0,#12
;;;517    {
;;;518        rMPLLCON = (nMdiv<<12) | (nPdiv<<4) | nSdiv;
0009fc  e1833201          ORR      r3,r3,r1,LSL #4
000a00  e1833002          ORR      r3,r3,r2
000a04  e3a0c313          MOV      r12,#0x4c000000
000a08  e58c3004          STR      r3,[r12,#4]
;;;519    }
000a0c  e12fff1e          BX       lr
;;;520    
                          ENDP

                  change_clock_divider PROC
;;;528    *********************************************************************************************/
;;;529    void change_clock_divider(int nHdiv,int nPdiv)
000a10  e1812080          ORR      r2,r1,r0,LSL #1
;;;530    {
;;;531         // nHdiv,nPdiv FCLK:HCLK:PCLK
;;;532         //     0,0         1:1:1 
;;;533         //     0,1         1:1:2 
;;;534         //     1,0         1:2:2
;;;535         //     1,1         1:2:4
;;;536        rCLKDIVN = (nHdiv<<1) | nPdiv;    
000a14  e3a03313          MOV      r3,#0x4c000000
000a18  e5832014          STR      r2,[r3,#0x14]
;;;537        
;;;538    }
000a1c  e12fff1e          BX       lr
;;;539    
                          ENDP

                  ChangeUPllValue PROC
;;;547    *********************************************************************************************/
;;;548    void ChangeUPllValue(int nMdiv,int nPdiv,int nSdiv)
000a20  e1a03600          LSL      r3,r0,#12
;;;549    {
;;;550        rUPLLCON = (nMdiv<<12) | (nPdiv<<4) | nSdiv;
000a24  e1833201          ORR      r3,r3,r1,LSL #4
000a28  e1833002          ORR      r3,r3,r2
000a2c  e3a0c313          MOV      r12,#0x4c000000
000a30  e58c3008          STR      r3,[r12,#8]
;;;551    }
000a34  e12fff1e          BX       lr
;;;552    
                          ENDP

                  EnableMMU PROC
;;;596    *********************************************************************************************/
;;;597    void EnableMMU()
000a38  e1a00000          MOV      r0,r0
;;;598    {
;;;599    	unsigned int ctl;
;;;600    
;;;601    	ctl = ARM_ReadControl();
000a3c  ee111f10          MRC      p15,#0x0,r1,c1,c0,#0
000a40  e1a00000          MOV      r0,r0
000a44  e1a00001          MOV      r0,r1
;;;602    	ctl |= (1 << 0);
000a48  e3800001          ORR      r0,r0,#1
;;;603    	ARM_WriteControl(ctl);
000a4c  e1a01000          MOV      r1,r0
000a50  ee011f10          MCR      p15,#0x0,r1,c1,c0,#0
000a54  e1a00000          MOV      r0,r0
;;;604    }
000a58  e12fff1e          BX       lr
;;;605    
                          ENDP

                  InitMMU PROC
;;;613    *********************************************************************************************/
;;;614    void InitMMU(unsigned int *pTranslationTable)
000a5c  e92d4010          PUSH     {r4,lr}
;;;615    {
000a60  e1a03000          MOV      r3,r0
000a64  e1a00723          LSR      r0,r3,#14
000a68  e1a00700          LSL      r0,r0,#14
000a6c  ee020f10          MCR      p15,#0x0,r0,c2,c0,#0
000a70  e1a00000          MOV      r0,r0
;;;616    	int i;
;;;617    	// Program the TTB
;;;618    	ARM_WriteTTB((unsigned int) pTranslationTable);
;;;619    	// Program the domain access register
;;;620    	ARM_WriteDomain(0xC0000000); 		// domain 15: access are not checked
000a74  e3a00103          MOV      r0,#0xc0000000
000a78  ee030f10          MCR      p15,#0x0,r0,c3,c0,#0
000a7c  e1a00000          MOV      r0,r0
;;;621    
;;;622    	// Reset table entries
;;;623    	for (i = 0; i < 0x200; ++i)
000a80  e3a04000          MOV      r4,#0
000a84  ea000002          B        |L1.2708|
                  |L1.2696|
;;;624    		pTranslationTable[i] = 0;
000a88  e3a00000          MOV      r0,#0
000a8c  e7830104          STR      r0,[r3,r4,LSL #2]
000a90  e2844001          ADD      r4,r4,#1              ;623
                  |L1.2708|
000a94  e3540c02          CMP      r4,#0x200             ;623
000a98  bafffffa          BLT      |L1.2696|
;;;625    
;;;626    	// Program level 1 page table entry
;;;627    	pTranslationTable[0x0] =
000a9c  e59f0054          LDR      r0,|L1.2808|
000aa0  e5830000          STR      r0,[r3,#0]
;;;628    		(0x300 << 20) |  				// Physical Address
;;;629    		(1 << 10) |      				// Access in supervisor mode
;;;630    		(15 << 5) |      				// Domain
;;;631    		1 << 4 |
;;;632    		0x2;             				// Set as 1 Mbyte section
;;;633    	pTranslationTable[0x1] =
000aa4  e2800601          ADD      r0,r0,#0x100000
000aa8  e5830004          STR      r0,[r3,#4]
;;;634    		(0x301 << 20) |  				// Physical Address
;;;635    		(1 << 10) |      				// Access in supervisor mode
;;;636    		(15 << 5) |      				// Domain
;;;637    		1 << 4 |
;;;638    		0x2;             				// Set as 1 Mbyte section
;;;639    	pTranslationTable[0x2] =
000aac  e2800601          ADD      r0,r0,#0x100000
000ab0  e5830008          STR      r0,[r3,#8]
;;;640    		(0x302 << 20) |  				// Physical Address
;;;641    		(1 << 10) |      				// Access in supervisor mode
;;;642    		(15 << 5) |      				// Domain
;;;643    		1 << 4 |
;;;644    		0x2;             				// Set as 1 Mbyte section
;;;645    	pTranslationTable[0x3] =
000ab4  e2800601          ADD      r0,r0,#0x100000
000ab8  e583000c          STR      r0,[r3,#0xc]
;;;646    		(0x303 << 20) |  				// Physical Address
;;;647    		(1 << 10) |      				// Access in supervisor mode
;;;648    		(15 << 5) |      				// Domain
;;;649    		1 << 4 |
;;;650    		0x2;             				// Set as 1 Mbyte section
;;;651    
;;;652    	for(i = 0x200; i < 0xFFF; ++i)
000abc  e3a04c02          MOV      r4,#0x200
000ac0  ea000005          B        |L1.2780|
                  |L1.2756|
;;;653    		pTranslationTable[i] = 
000ac4  e3a00b01          MOV      r0,#0x400
000ac8  e1800a04          ORR      r0,r0,r4,LSL #20
000acc  e3800c01          ORR      r0,r0,#0x100
000ad0  e38000f2          ORR      r0,r0,#0xf2
000ad4  e7830104          STR      r0,[r3,r4,LSL #2]
000ad8  e2844001          ADD      r4,r4,#1              ;652
                  |L1.2780|
000adc  e59f0018          LDR      r0,|L1.2812|
000ae0  e1540000          CMP      r4,r0                 ;652
000ae4  bafffff6          BLT      |L1.2756|
;;;654    			(i << 20) |  				// Physical Address
;;;655    			(1 << 10) |      			// Access in supervisor mode
;;;656    			(15 << 5) |      			// Domain
;;;657    			1 << 4 |
;;;658    			0x2;             			// Set as 1 Mbyte section
;;;659    
;;;660    	EnableMMU();		 				// Enable the MMU
000ae8  ebfffffe          BL       EnableMMU
;;;661    }
000aec  e8bd4010          POP      {r4,lr}
000af0  e12fff1e          BX       lr
;;;662    
                          ENDP

                  __gccmain PROC
;;;670    *********************************************************************************************/
;;;671    void __gccmain(void)
000af4  e12fff1e          BX       lr
;;;672    {
;;;673    }
                          ENDP

                  |L1.2808|
                          DCD      0x300005f2
                  |L1.2812|
                          DCD      0x00000fff

                          AREA ||.data||, DATA, ALIGN=2

                  delayLoopCount
                          DCD      0x000007ec
                  f_nWhichUart
                          DCD      0x00000000
                  ||Image$$RW_ZI$$ZI$$Limit||
000008  00                DCB      0x00

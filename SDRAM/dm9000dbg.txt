; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\SDRAM\dm9000dbg.o --asm_dir=.\SDRAM\ --list_dir=.\SDRAM\ --depend=.\SDRAM\dm9000dbg.d --cpu=ARM920T --apcs=interwork -O0 -I..\Common\Inc -I.\INC -I.\INC\tftp -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Samsung --omf_browse=.\SDRAM\dm9000dbg.crf Source\tftp\dm9000dbg.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ReadReg PROC
;;;60     static UINT8T
;;;61     ReadReg(UINT16T offset)
000000  e1a01000          MOV      r1,r0
;;;62     {
;;;63      IOWRITE(dwEthernetIOBase, offset);
000004  e59f22b4          LDR      r2,|L1.704|
000008  e5922000          LDR      r2,[r2,#0]  ; dwEthernetIOBase
00000c  e5c21000          STRB     r1,[r2,#0]
;;;64      return IOREAD(dwEthernetDataPort);
000010  e59f02ac          LDR      r0,|L1.708|
000014  e5900000          LDR      r0,[r0,#0]  ; dwEthernetDataPort
000018  e5d00000          LDRB     r0,[r0,#0]
;;;65     }
00001c  e12fff1e          BX       lr
;;;66     
                          ENDP

                  WriteReg PROC
;;;67     static void
;;;68     WriteReg(UINT16T offset, UINT8T data)
000020  e59f3298          LDR      r3,|L1.704|
;;;69     {
;;;70      IOWRITE(dwEthernetIOBase, offset);
000024  e5933000          LDR      r3,[r3,#0]  ; dwEthernetIOBase
000028  e5c30000          STRB     r0,[r3,#0]
;;;71      IOWRITE(dwEthernetDataPort, data);
00002c  e59f2290          LDR      r2,|L1.708|
000030  e5922000          LDR      r2,[r2,#0]  ; dwEthernetDataPort
000034  e5c21000          STRB     r1,[r2,#0]
;;;72     }
000038  e12fff1e          BX       lr
;;;73     
                          ENDP

                  CalculateHashIndex PROC
;;;81     */
;;;82     UINT8T CalculateHashIndex( UINT8T  *pMulticastAddr )
00003c  e92d0070          PUSH     {r4-r6}
;;;83     {
000040  e1a03000          MOV      r3,r0
;;;84        UINT32T CRC;
;;;85        UINT8T  HashIndex;
;;;86        UINT8T  AddrByte;
;;;87        UINT32T HighBit;
;;;88        int   Byte;
;;;89        int   Bit;
;;;90     
;;;91        // Prime the CRC.
;;;92        CRC = CRC_PRIME;
000044  e3e01000          MVN      r1,#0
;;;93     
;;;94        // For each of the six bytes of the multicast address.
;;;95        for ( Byte=0; Byte<6; Byte++ )
000048  e3a04000          MOV      r4,#0
00004c  ea00000f          B        |L1.144|
                  |L1.80|
;;;96        {
;;;97           AddrByte = *pMulticastAddr++;
000050  e4d3c001          LDRB     r12,[r3],#1
;;;98     
;;;99           // For each bit of the byte.
;;;100          for ( Bit=8; Bit>0; Bit-- )
000054  e3a02008          MOV      r2,#8
000058  ea000009          B        |L1.132|
                  |L1.92|
;;;101          {
;;;102             HighBit = CRC >> 31;
00005c  e1a05fa1          LSR      r5,r1,#31
;;;103             CRC <<= 1;
000060  e1a01081          LSL      r1,r1,#1
;;;104    
;;;105             if ( HighBit ^ (AddrByte & 1) )
000064  e20c6001          AND      r6,r12,#1
000068  e1360005          TEQ      r6,r5
00006c  0a000002          BEQ      |L1.124|
;;;106             {
;;;107                CRC ^= CRC_POLYNOMIAL;
000070  e59f6250          LDR      r6,|L1.712|
000074  e0211006          EOR      r1,r1,r6
;;;108                CRC |= 1;
000078  e3811001          ORR      r1,r1,#1
                  |L1.124|
;;;109             }
;;;110    
;;;111             AddrByte >>= 1;
00007c  e1a0c0cc          ASR      r12,r12,#1
000080  e2422001          SUB      r2,r2,#1              ;100
                  |L1.132|
000084  e3520000          CMP      r2,#0                 ;100
000088  cafffff3          BGT      |L1.92|
00008c  e2844001          ADD      r4,r4,#1              ;95
                  |L1.144|
000090  e3540006          CMP      r4,#6                 ;95
000094  baffffed          BLT      |L1.80|
;;;112          }
;;;113       }
;;;114    
;;;115       // Take the least significant six bits of the CRC and copy them
;;;116       // to the HashIndex in reverse order.
;;;117       for( Bit=0,HashIndex=0; Bit<6; Bit++ )
000098  e3a02000          MOV      r2,#0
00009c  e3a00000          MOV      r0,#0
0000a0  ea000005          B        |L1.188|
                  |L1.164|
;;;118       {
;;;119          HashIndex <<= 1;
0000a4  e1a06c80          LSL      r6,r0,#25
0000a8  e1a00c26          LSR      r0,r6,#24
;;;120          HashIndex |= (UINT8T)(CRC & 1);
0000ac  e2016001          AND      r6,r1,#1
0000b0  e1800006          ORR      r0,r0,r6
;;;121          CRC >>= 1;
0000b4  e1a010a1          LSR      r1,r1,#1
0000b8  e2822001          ADD      r2,r2,#1              ;117
                  |L1.188|
0000bc  e3520006          CMP      r2,#6                 ;117
0000c0  bafffff7          BLT      |L1.164|
0000c4  e8bd0070          POP      {r4-r6}               ;117
;;;122       }
;;;123    
;;;124       return(HashIndex);
;;;125    }
0000c8  e12fff1e          BX       lr
;;;126    
                          ENDP

                  DM9000_Delay PROC
;;;127    void DM9000_Delay(UINT32T dwCounter)
0000cc  e1a00000          MOV      r0,r0
                  |L1.208|
;;;128    {
;;;129     // Simply loop...
;;;130     while (dwCounter--);
0000d0  e1b01000          MOVS     r1,r0
0000d4  e2400001          SUB      r0,r0,#1
0000d8  1afffffc          BNE      |L1.208|
;;;131    } 
0000dc  e12fff1e          BX       lr
;;;132    
                          ENDP

                  dm9000_hash_table PROC
;;;133    void dm9000_hash_table(UINT16T *mac)
0000e0  e92d4070          PUSH     {r4-r6,lr}
;;;134    {
0000e4  e1a04000          MOV      r4,r0
;;;135     UINT16T i, oft;
;;;136    
;;;137     uart_printf("dm9000_hash_table\r\n");
0000e8  e28f0f77          ADR      r0,|L1.716|
0000ec  ebfffffe          BL       uart_printf
;;;138     /* Set Node address */
;;;139     WRITE_REG1(0x10, (UINT8T)(mac[0] & 0xFF));
0000f0  e5d41000          LDRB     r1,[r4,#0]
0000f4  e3a00010          MOV      r0,#0x10
0000f8  ebfffffe          BL       WriteReg
;;;140     WRITE_REG1(0x11, (UINT8T)(mac[0] >> 8));
0000fc  e1d400b0          LDRH     r0,[r4,#0]
000100  e1a01440          ASR      r1,r0,#8
000104  e3a00011          MOV      r0,#0x11
000108  ebfffffe          BL       WriteReg
;;;141     WRITE_REG1(0x12, (UINT8T)(mac[1] & 0xFF));
00010c  e5d41002          LDRB     r1,[r4,#2]
000110  e3a00012          MOV      r0,#0x12
000114  ebfffffe          BL       WriteReg
;;;142     WRITE_REG1(0x13, (UINT8T)(mac[1] >> 8));
000118  e1d400b2          LDRH     r0,[r4,#2]
00011c  e1a01440          ASR      r1,r0,#8
000120  e3a00013          MOV      r0,#0x13
000124  ebfffffe          BL       WriteReg
;;;143     WRITE_REG1(0x14, (UINT8T)(mac[2] & 0xFF));
000128  e5d41004          LDRB     r1,[r4,#4]
00012c  e3a00014          MOV      r0,#0x14
000130  ebfffffe          BL       WriteReg
;;;144     WRITE_REG1(0x15, (UINT8T)(mac[2] >> 8)); 
000134  e1d400b4          LDRH     r0,[r4,#4]
000138  e1a01440          ASR      r1,r0,#8
00013c  e3a00015          MOV      r0,#0x15
000140  ebfffffe          BL       WriteReg
;;;145    
;;;146     /* Clear Hash Table */
;;;147     for (i = 0; i < 4; i++)
000144  e3a05000          MOV      r5,#0
000148  ea000005          B        |L1.356|
                  |L1.332|
;;;148      hash_table[i] = 0x0;
00014c  e3a00000          MOV      r0,#0
000150  e59f1188          LDR      r1,|L1.736|
000154  e0811085          ADD      r1,r1,r5,LSL #1
000158  e1c100b0          STRH     r0,[r1,#0]
00015c  e2850001          ADD      r0,r5,#1              ;147
000160  e3c05801          BIC      r5,r0,#0x10000        ;147
                  |L1.356|
000164  e3550004          CMP      r5,#4                 ;147
000168  bafffff7          BLT      |L1.332|
;;;149    
;;;150     /* broadcast address */
;;;151     hash_table[3] = 0x8000;
00016c  e3a00902          MOV      r0,#0x8000
000170  e59f1168          LDR      r1,|L1.736|
000174  e1c100b6          STRH     r0,[r1,#6]  ; hash_table
;;;152     /* Write the hash table to MAC MD table */
;;;153     for (i = 0, oft = 0x16; i < 4; i++)
000178  e3a05000          MOV      r5,#0
00017c  e3a06016          MOV      r6,#0x16
000180  ea00000f          B        |L1.452|
                  |L1.388|
;;;154     {
;;;155      WRITE_REG1(oft++, (UINT8T)(hash_table[i] & 0xff));
000184  e59f2154          LDR      r2,|L1.736|
000188  e7d21085          LDRB     r1,[r2,r5,LSL #1]
00018c  e1a00006          MOV      r0,r6
000190  e2863001          ADD      r3,r6,#1
000194  e3c36801          BIC      r6,r3,#0x10000
000198  ebfffffe          BL       WriteReg
;;;156      WRITE_REG1(oft++, (UINT8T)((hash_table[i] >> 8) & 0xff));
00019c  e59f213c          LDR      r2,|L1.736|
0001a0  e0822085          ADD      r2,r2,r5,LSL #1
0001a4  e1d220b0          LDRH     r2,[r2,#0]
0001a8  e1a01442          ASR      r1,r2,#8
0001ac  e1a00006          MOV      r0,r6
0001b0  e2863001          ADD      r3,r6,#1
0001b4  e3c36801          BIC      r6,r3,#0x10000
0001b8  ebfffffe          BL       WriteReg
0001bc  e2850001          ADD      r0,r5,#1              ;153
0001c0  e3c05801          BIC      r5,r0,#0x10000        ;153
                  |L1.452|
0001c4  e3550004          CMP      r5,#4                 ;153
0001c8  baffffed          BLT      |L1.388|
;;;157     }
;;;158      
;;;159    
;;;160    }
0001cc  e8bd4070          POP      {r4-r6,lr}
0001d0  e12fff1e          BX       lr
;;;161    
                          ENDP

                  Probe PROC
;;;167     */
;;;168    static int Probe(void)
0001d4  e92d4070          PUSH     {r4-r6,lr}
;;;169    {
;;;170     int r = FALSE;
0001d8  e3a05000          MOV      r5,#0
;;;171     UINT32T id_val;
;;;172    
;;;173    
;;;174     uart_printf("detected DM9000...\r\n"); 
0001dc  e28f0c01          ADR      r0,|L1.740|
0001e0  ebfffffe          BL       uart_printf
;;;175     uart_printf ( "dwEthernetIOBase =  %x\r\n",dwEthernetIOBase);
0001e4  e59f00d4          LDR      r0,|L1.704|
0001e8  e5901000          LDR      r1,[r0,#0]  ; dwEthernetIOBase
0001ec  e28f0f42          ADR      r0,|L1.764|
0001f0  ebfffffe          BL       uart_printf
;;;176     uart_printf ( "dwEthernetDataPort =  %x\r\n",dwEthernetDataPort);
0001f4  e59f00c8          LDR      r0,|L1.708|
0001f8  e5901000          LDR      r1,[r0,#0]  ; dwEthernetDataPort
0001fc  e28f0f45          ADR      r0,|L1.792|
000200  ebfffffe          BL       uart_printf
;;;177     
;;;178     id_val  = READ_REG1(0x28);
000204  e3a00028          MOV      r0,#0x28
000208  ebfffffe          BL       ReadReg
00020c  e1a04000          MOV      r4,r0
;;;179     id_val |= READ_REG1(0x29) << 8;
000210  e3a00029          MOV      r0,#0x29
000214  ebfffffe          BL       ReadReg
000218  e1844400          ORR      r4,r4,r0,LSL #8
;;;180     id_val |= READ_REG1(0x2a) << 16;
00021c  e3a0002a          MOV      r0,#0x2a
000220  ebfffffe          BL       ReadReg
000224  e1844800          ORR      r4,r4,r0,LSL #16
;;;181     id_val |= READ_REG1(0x2b) << 24;
000228  e3a0002b          MOV      r0,#0x2b
00022c  ebfffffe          BL       ReadReg
000230  e1844c00          ORR      r4,r4,r0,LSL #24
;;;182    
;;;183    uart_printf ( "id_val =  %x\r\n",id_val);
000234  e1a01004          MOV      r1,r4
000238  e28f00f4          ADR      r0,|L1.820|
00023c  ebfffffe          BL       uart_printf
;;;184     
;;;185     if (id_val == DM9000_ID) {
000240  e59f00fc          LDR      r0,|L1.836|
000244  e1540000          CMP      r4,r0
000248  1a00000b          BNE      |L1.636|
;;;186      uart_printf("INFO: Probe: DM9000 is detected.\r\n");
00024c  e28f00f4          ADR      r0,|L1.840|
000250  ebfffffe          BL       uart_printf
;;;187      DM9000_rev = READ_REG1(0x2c);
000254  e3a0002c          MOV      r0,#0x2c
000258  ebfffffe          BL       ReadReg
00025c  e59f1108          LDR      r1,|L1.876|
000260  e5c10000          STRB     r0,[r1,#0]  ; DM9000_rev
;;;188      uart_printf("INFO:CHIP Revision is:%d\n",DM9000_rev);
000264  e2810000          ADD      r0,r1,#0
000268  e5d01000          LDRB     r1,[r0,#0]  ; DM9000_rev
00026c  e28f00fc          ADR      r0,|L1.880|
000270  ebfffffe          BL       uart_printf
;;;189    
;;;190      
;;;191      r = TRUE;
000274  e3a05001          MOV      r5,#1
000278  ea000001          B        |L1.644|
                  |L1.636|
;;;192     }
;;;193     else {
;;;194      uart_printf("ERROR: Probe: Can not find DM9000.\r\n");
00027c  e28f0f42          ADR      r0,|L1.908|
000280  ebfffffe          BL       uart_printf
                  |L1.644|
;;;195     }
;;;196    
;;;197     return r;
000284  e1a00005          MOV      r0,r5
000288  e8bd4070          POP      {r4-r6,lr}
;;;198    }
00028c  e12fff1e          BX       lr
;;;199    
                          ENDP

                  DM9000DBG_EnableInts PROC
;;;205     */
;;;206    void DM9000DBG_EnableInts(void)
000290  e92d4010          PUSH     {r4,lr}
;;;207    {
;;;208     /*only enable RX interrupt*/
;;;209     WRITE_REG1(0xff, 0x81);
000294  e3a01081          MOV      r1,#0x81
000298  e3a000ff          MOV      r0,#0xff
00029c  ebfffffe          BL       WriteReg
;;;210    }
0002a0  e8bd4010          POP      {r4,lr}
0002a4  e12fff1e          BX       lr
;;;211    /*
                          ENDP

                  DM9000DBG_DisableInts PROC
;;;216    
;;;217    void DM9000DBG_DisableInts(void)
0002a8  e92d4010          PUSH     {r4,lr}
;;;218    {
;;;219     WRITE_REG1(0xff, 0x80);
0002ac  e3a01080          MOV      r1,#0x80
0002b0  e3a000ff          MOV      r0,#0xff
0002b4  ebfffffe          BL       WriteReg
;;;220    }
0002b8  e8bd4010          POP      {r4,lr}
0002bc  e12fff1e          BX       lr
                  |L1.704|
                          DCD      dwEthernetIOBase
                  |L1.708|
                          DCD      dwEthernetDataPort
                  |L1.712|
                          DCD      0x04c11db6
                  |L1.716|
0002cc  646d3930          DCB      "dm9000_hash_table\r\n",0
0002d0  30305f68
0002d4  6173685f
0002d8  7461626c
0002dc  650d0a00
                  |L1.736|
                          DCD      hash_table
                  |L1.740|
0002e4  64657465          DCB      "detected DM9000...\r\n",0
0002e8  63746564
0002ec  20444d39
0002f0  3030302e
0002f4  2e2e0d0a
0002f8  00      
0002f9  00                DCB      0
0002fa  00                DCB      0
0002fb  00                DCB      0
                  |L1.764|
0002fc  64774574          DCB      "dwEthernetIOBase =  %x\r\n",0
000300  6865726e
000304  6574494f
000308  42617365
00030c  203d2020
000310  25780d0a
000314  00      
000315  00                DCB      0
000316  00                DCB      0
000317  00                DCB      0
                  |L1.792|
000318  64774574          DCB      "dwEthernetDataPort =  %x\r\n",0
00031c  6865726e
000320  65744461
000324  7461506f
000328  7274203d
00032c  20202578
000330  0d0a00  
000333  00                DCB      0
                  |L1.820|
000334  69645f76          DCB      "id_val =  %x\r\n",0
000338  616c203d
00033c  20202578
000340  0d0a00  
000343  00                DCB      0
                  |L1.836|
                          DCD      0x90000a46
                  |L1.840|
000348  494e464f          DCB      "INFO: Probe: DM9000 is detected.\r\n",0
00034c  3a205072
000350  6f62653a
000354  20444d39
000358  30303020
00035c  69732064
000360  65746563
000364  7465642e
000368  0d0a00  
00036b  00                DCB      0
                  |L1.876|
                          DCD      DM9000_rev
                  |L1.880|
000370  494e464f          DCB      "INFO:CHIP Revision is:%d\n",0
000374  3a434849
000378  50205265
00037c  76697369
000380  6f6e2069
000384  733a2564
000388  0a00    
00038a  00                DCB      0
00038b  00                DCB      0
                  |L1.908|
00038c  4552524f          DCB      "ERROR: Probe: Can not find DM9000.\r\n",0
000390  523a2050
000394  726f6265
000398  3a204361
00039c  6e206e6f
0003a0  74206669
0003a4  6e642044
0003a8  4d393030
0003ac  302e0d0a
0003b0  00      
0003b1  00                DCB      0
0003b2  00                DCB      0
0003b3  00                DCB      0
                          ENDP

                  dm9000_send PROC
;;;223    
;;;224     int dm9000_send (UINT8T *pbData,unsigned int length)
0003b4  e92d41f0          PUSH     {r4-r8,lr}
;;;225    { 
0003b8  e1a07000          MOV      r7,r0
0003bc  e1a05001          MOV      r5,r1
;;;226     int i;
;;;227     int tmplen;
;;;228    
;;;229    
;;;230     IOWRITE(dwEthernetIOBase, 0xf8); /* data copy ready set */
0003c0  e3a000f8          MOV      r0,#0xf8
0003c4  e51f110c          LDR      r1,|L1.704|
0003c8  e5911000          LDR      r1,[r1,#0]  ; dwEthernetIOBase
0003cc  e5c10000          STRB     r0,[r1,#0]
;;;231     /* copy data to FIFO */
;;;232     switch (DM9000_iomode)
0003d0  e59f02c0          LDR      r0,|L1.1688|
0003d4  e5d00000          LDRB     r0,[r0,#0]  ; DM9000_iomode
0003d8  e3500000          CMP      r0,#0
0003dc  0a00000e          BEQ      |L1.1052|
0003e0  e3500001          CMP      r0,#1
0003e4  0a00001a          BEQ      |L1.1108|
0003e8  e3500002          CMP      r0,#2
0003ec  1a000025          BNE      |L1.1160|
;;;233     {
;;;234      case DM9000_BYTE_MODE:
;;;235       tmplen = length ;  
0003f0  e1a06005          MOV      r6,r5
;;;236       for (i = 0; i < tmplen; i++)
0003f4  e3a04000          MOV      r4,#0
0003f8  ea000004          B        |L1.1040|
                  |L1.1020|
;;;237       IOWRITE(dwEthernetDataPort, ((UINT8T *)pbData)[i]);
0003fc  e7d70004          LDRB     r0,[r7,r4]
000400  e51f1144          LDR      r1,|L1.708|
000404  e5911000          LDR      r1,[r1,#0]  ; dwEthernetDataPort
000408  e5c10000          STRB     r0,[r1,#0]
00040c  e2844001          ADD      r4,r4,#1              ;236
                  |L1.1040|
000410  e1540006          CMP      r4,r6                 ;236
000414  bafffff8          BLT      |L1.1020|
;;;238       break;
000418  ea00001d          B        |L1.1172|
                  |L1.1052|
;;;239      case DM9000_WORD_MODE:
00041c  e1a00000          MOV      r0,r0
;;;240       tmplen = (length+1)/2;
000420  e2850001          ADD      r0,r5,#1
000424  e1a060a0          LSR      r6,r0,#1
;;;241       for (i = 0; i < tmplen; i++)
000428  e3a04000          MOV      r4,#0
00042c  ea000005          B        |L1.1096|
                  |L1.1072|
;;;242               IOWRITE16(dwEthernetDataPort, ((UINT16T *)pbData)[i]);
000430  e0870084          ADD      r0,r7,r4,LSL #1
000434  e1d000b0          LDRH     r0,[r0,#0]
000438  e51f117c          LDR      r1,|L1.708|
00043c  e5911000          LDR      r1,[r1,#0]  ; dwEthernetDataPort
000440  e1c100b0          STRH     r0,[r1,#0]
000444  e2844001          ADD      r4,r4,#1              ;241
                  |L1.1096|
000448  e1540006          CMP      r4,r6                 ;241
00044c  bafffff7          BLT      |L1.1072|
;;;243       break;
000450  ea00000f          B        |L1.1172|
                  |L1.1108|
;;;244      case DM9000_DWORD_MODE:
000454  e1a00000          MOV      r0,r0
;;;245       tmplen = (length+3)/4;
000458  e2850003          ADD      r0,r5,#3
00045c  e1a06120          LSR      r6,r0,#2
;;;246       for (i = 0; i < tmplen; i++)
000460  e3a04000          MOV      r4,#0
000464  ea000004          B        |L1.1148|
                  |L1.1128|
;;;247               IOWRITE32(dwEthernetDataPort, ((UINT32T *)pbData)[i]);
000468  e7970104          LDR      r0,[r7,r4,LSL #2]
00046c  e51f11b0          LDR      r1,|L1.708|
000470  e5911000          LDR      r1,[r1,#0]  ; dwEthernetDataPort
000474  e5810000          STR      r0,[r1,#0]
000478  e2844001          ADD      r4,r4,#1              ;246
                  |L1.1148|
00047c  e1540006          CMP      r4,r6                 ;246
000480  bafffff8          BLT      |L1.1128|
;;;248      default:
000484  e1a00000          MOV      r0,r0
                  |L1.1160|
;;;249       uart_printf("[DM9000][TX]Move data error!!!");
000488  e28f0f83          ADR      r0,|L1.1692|
00048c  ebfffffe          BL       uart_printf
;;;250       break;
000490  e1a00000          MOV      r0,r0
                  |L1.1172|
000494  e1a00000          MOV      r0,r0                 ;238
;;;251     }
;;;252     /*set packet leng */
;;;253     WRITE_REG1(0xfd, (length >> 8) & 0xff); 
000498  e1a00805          LSL      r0,r5,#16
00049c  e1a01c20          LSR      r1,r0,#24
0004a0  e3a000fd          MOV      r0,#0xfd
0004a4  ebfffffe          BL       WriteReg
;;;254     WRITE_REG1(0xfc, length & 0xff);
0004a8  e20510ff          AND      r1,r5,#0xff
0004ac  e3a000fc          MOV      r0,#0xfc
0004b0  ebfffffe          BL       WriteReg
;;;255     /* start transmit */
;;;256     WRITE_REG1(0x02, 1);
0004b4  e3a01001          MOV      r1,#1
0004b8  e3a00002          MOV      r0,#2
0004bc  ebfffffe          BL       WriteReg
;;;257     
;;;258     /*wait TX complete*/
;;;259     while(1)
0004c0  ea000009          B        |L1.1260|
                  |L1.1220|
;;;260     {
;;;261      if (READ_REG1(0xfe) & 2) { //TX completed
0004c4  e3a000fe          MOV      r0,#0xfe
0004c8  ebfffffe          BL       ReadReg
0004cc  e3100002          TST      r0,#2
0004d0  0a000003          BEQ      |L1.1252|
;;;262       WRITE_REG1(0xfe, 2);
0004d4  e3a01002          MOV      r1,#2
0004d8  e3a000fe          MOV      r0,#0xfe
0004dc  ebfffffe          BL       WriteReg
;;;263       break;
0004e0  ea000002          B        |L1.1264|
                  |L1.1252|
;;;264      }
;;;265      DM9000_Delay(1000);
0004e4  e3a00ffa          MOV      r0,#0x3e8
0004e8  ebfffffe          BL       DM9000_Delay
                  |L1.1260|
0004ec  eafffff4          B        |L1.1220|
                  |L1.1264|
0004f0  e1a00000          MOV      r0,r0                 ;263
;;;266     }
;;;267     return 0;
0004f4  e3a00000          MOV      r0,#0
0004f8  e8bd41f0          POP      {r4-r8,lr}
;;;268    }
0004fc  e12fff1e          BX       lr
;;;269    
                          ENDP

                  DM9000DBG_Init PROC
;;;274    
;;;275    int DM9000DBG_Init(void )
000500  e92d40fe          PUSH     {r1-r7,lr}
;;;276    {
;;;277    
;;;278        int r = FALSE;
000504  e3a04000          MOV      r4,#0
;;;279    	UINT32T temp;
;;;280    	// Core DM9000
;;;281    
;;;282    	dwEthernetIOBase   = 0x20000000;
000508  e3a00202          MOV      r0,#0x20000000
00050c  e51f1254          LDR      r1,|L1.704|
000510  e5810000          STR      r0,[r1,#0]  ; dwEthernetIOBase
;;;283    	dwEthernetDataPort = 0x20100000;
000514  e18004c0          ORR      r0,r0,r0,ASR #9
000518  e51f125c          LDR      r1,|L1.708|
00051c  e5810000          STR      r0,[r1,#0]  ; dwEthernetDataPort
;;;284       
;;;285         r = Probe(); /*Detect DM9000 */
000520  ebfffffe          BL       Probe
000524  e1a04000          MOV      r4,r0
;;;286    
;;;287    	 
;;;288        MacAddr[0] = 0x0000;
000528  e3a00000          MOV      r0,#0
00052c  e59f1188          LDR      r1,|L1.1724|
000530  e1c100b0          STRH     r0,[r1,#0]  ; MacAddr
;;;289    	MacAddr[1] = 0x1232;
000534  e59f0184          LDR      r0,|L1.1728|
000538  e1c100b2          STRH     r0,[r1,#2]  ; MacAddr
;;;290    	MacAddr[2] = 0x1233;
00053c  e1800640          ORR      r0,r0,r0,ASR #12
000540  e1c100b4          STRH     r0,[r1,#4]  ; MacAddr
;;;291        uart_printf("DM9000: MAC Address: %u:%u:%u:%u:%u:%u\r\n",
000544  e2810000          ADD      r0,r1,#0
000548  e1d000b4          LDRH     r0,[r0,#4]  ; MacAddr
00054c  e1a00440          ASR      r0,r0,#8
000550  e5d11004          LDRB     r1,[r1,#4]  ; MacAddr
000554  e59f2160          LDR      r2,|L1.1724|
000558  e1d220b2          LDRH     r2,[r2,#2]  ; MacAddr
00055c  e1a02442          ASR      r2,r2,#8
000560  e58d0008          STR      r0,[sp,#8]
000564  e59f0150          LDR      r0,|L1.1724|
000568  e58d1004          STR      r1,[sp,#4]
00056c  e58d2000          STR      r2,[sp,#0]
000570  e5d03002          LDRB     r3,[r0,#2]  ; MacAddr
000574  e1d000b0          LDRH     r0,[r0,#0]  ; MacAddr
000578  e1a02440          ASR      r2,r0,#8
00057c  e59f0138          LDR      r0,|L1.1724|
000580  e5d01000          LDRB     r1,[r0,#0]  ; MacAddr
000584  e28f0f4e          ADR      r0,|L1.1732|
000588  ebfffffe          BL       uart_printf
;;;292        MacAddr[0] & 0x00FF, MacAddr[0] >> 8,
;;;293        MacAddr[1] & 0x00FF, MacAddr[1] >> 8,
;;;294        MacAddr[2] & 0x00FF, MacAddr[2] >> 8);
;;;295    
;;;296    	if(r == FALSE)
00058c  e3540000          CMP      r4,#0
000590  1a000002          BNE      |L1.1440|
;;;297    	{
;;;298    	    return FALSE; 
000594  e3a00000          MOV      r0,#0
                  |L1.1432|
000598  e8bd40fe          POP      {r1-r7,lr}
;;;299    	}
;;;300    
;;;301    	 /* set the internal PHY power-on, GPIOs normal */
;;;302    	 WRITE_REG1(0x1f, 0); /* GPR (reg_1Fh)bit GPIO0=0 pre-activate PHY */ 
;;;303    	 DM9000_Delay(1000);
;;;304    
;;;305    	 /* do a software reset */
;;;306    	 WRITE_REG1(0x0, 3); /* NCR (reg_00h) bit[0] RST=1 & Loopback=1, reset on */
;;;307    	 DM9000_Delay(1000);
;;;308    	 WRITE_REG1(0x0, 3); /* NCR (reg_00h) bit[0] RST=1 & Loopback=1, reset on */ 
;;;309    	 DM9000_Delay(1000);
;;;310    
;;;311    	 /* I/O mode */
;;;312    	 DM9000_iomode = READ_REG1(0xfe) >> 6; /* ISR bit7:6 keeps I/O mode */
;;;313    
;;;314    	 /* Program operating register */
;;;315    	 WRITE_REG1(0x0, 0);
;;;316    	 WRITE_REG1(0x02, 0); /* TX Polling clear */
;;;317    	 WRITE_REG1(0x2f, 0); /* Special Mode */
;;;318    	 WRITE_REG1(0x01, 0x2c); /* clear TX status */
;;;319    	 WRITE_REG1(0xfe, 0x0f); /* Clear interrupt status */
;;;320    
;;;321    	 /* Set address filter table */
;;;322    	 dm9000_hash_table(MacAddr);
;;;323    
;;;324    	 /* Activate DM9000A/DM9010 */
;;;325    	 WRITE_REG1(0x05, 0x30 | 1); /* Discard long packet and CRC error packets*//* RX enable */     
;;;326    	 WRITE_REG1(0xff, 0x80);  /* Enable SRAM automatically return */
;;;327    	    
;;;328    	 /* wait link ok */
;;;329    	 
;;;330    
;;;331    	 while(1)
;;;332    	 {
;;;333    	         temp=READ_REG1(0x01)&0x40;
;;;334    	         if(temp)
;;;335    	         	{
;;;336    	         uart_printf ("link stauts = %x\r\n", READ_REG1(0x01));
;;;337    	         uart_printf("INFO: Init: DM9000_Init OK.\r\n");
;;;338    	            break;	
;;;339    	         	}
;;;340    		//uart_printf("wait for Ethernet link ...\r\n");
;;;341    	 }   
;;;342    
;;;343    	 return r;
;;;344    }
00059c  e12fff1e          BX       lr
                  |L1.1440|
0005a0  e3a01000          MOV      r1,#0                 ;302
0005a4  e3a0001f          MOV      r0,#0x1f              ;302
0005a8  ebfffffe          BL       WriteReg
0005ac  e3a00ffa          MOV      r0,#0x3e8             ;303
0005b0  ebfffffe          BL       DM9000_Delay
0005b4  e3a01003          MOV      r1,#3                 ;306
0005b8  e3a00000          MOV      r0,#0                 ;306
0005bc  ebfffffe          BL       WriteReg
0005c0  e3a00ffa          MOV      r0,#0x3e8             ;307
0005c4  ebfffffe          BL       DM9000_Delay
0005c8  e3a01003          MOV      r1,#3                 ;308
0005cc  e3a00000          MOV      r0,#0                 ;308
0005d0  ebfffffe          BL       WriteReg
0005d4  e3a00ffa          MOV      r0,#0x3e8             ;309
0005d8  ebfffffe          BL       DM9000_Delay
0005dc  e3a000fe          MOV      r0,#0xfe              ;312
0005e0  ebfffffe          BL       ReadReg
0005e4  e1a00340          ASR      r0,r0,#6              ;312
0005e8  e59f10a8          LDR      r1,|L1.1688|
0005ec  e5c10000          STRB     r0,[r1,#0]            ;312  ; DM9000_iomode
0005f0  e3a01000          MOV      r1,#0                 ;315
0005f4  e1a00001          MOV      r0,r1                 ;315
0005f8  ebfffffe          BL       WriteReg
0005fc  e3a01000          MOV      r1,#0                 ;316
000600  e3a00002          MOV      r0,#2                 ;316
000604  ebfffffe          BL       WriteReg
000608  e3a01000          MOV      r1,#0                 ;317
00060c  e3a0002f          MOV      r0,#0x2f              ;317
000610  ebfffffe          BL       WriteReg
000614  e3a0102c          MOV      r1,#0x2c              ;318
000618  e3a00001          MOV      r0,#1                 ;318
00061c  ebfffffe          BL       WriteReg
000620  e3a0100f          MOV      r1,#0xf               ;319
000624  e3a000fe          MOV      r0,#0xfe              ;319
000628  ebfffffe          BL       WriteReg
00062c  e59f0088          LDR      r0,|L1.1724|
000630  ebfffffe          BL       dm9000_hash_table
000634  e3a01031          MOV      r1,#0x31              ;325
000638  e3a00005          MOV      r0,#5                 ;325
00063c  ebfffffe          BL       WriteReg
000640  e3a01080          MOV      r1,#0x80              ;326
000644  e3a000ff          MOV      r0,#0xff              ;326
000648  ebfffffe          BL       WriteReg
00064c  ea00000d          B        |L1.1672|
                  |L1.1616|
000650  e3a00001          MOV      r0,#1                 ;333
000654  ebfffffe          BL       ReadReg
000658  e2005040          AND      r5,r0,#0x40           ;333
00065c  e3550000          CMP      r5,#0                 ;334
000660  0a000008          BEQ      |L1.1672|
000664  e3a00001          MOV      r0,#1                 ;336
000668  ebfffffe          BL       ReadReg
00066c  e1a06000          MOV      r6,r0                 ;336
000670  e1a01006          MOV      r1,r6                 ;336
000674  e28f0074          ADR      r0,|L1.1776|
000678  ebfffffe          BL       uart_printf
00067c  e28f0080          ADR      r0,|L1.1796|
000680  ebfffffe          BL       uart_printf
000684  ea000000          B        |L1.1676|
                  |L1.1672|
000688  eafffff0          B        |L1.1616|
                  |L1.1676|
00068c  e1a00000          MOV      r0,r0                 ;338
000690  e1a00004          MOV      r0,r4                 ;343
000694  eaffffbf          B        |L1.1432|
                  |L1.1688|
                          DCD      DM9000_iomode
                  |L1.1692|
00069c  5b444d39          DCB      "[DM9000][TX]Move data error!!!",0
0006a0  3030305d
0006a4  5b54585d
0006a8  4d6f7665
0006ac  20646174
0006b0  61206572
0006b4  726f7221
0006b8  212100  
0006bb  00                DCB      0
                  |L1.1724|
                          DCD      MacAddr
                  |L1.1728|
                          DCD      0x00001232
                  |L1.1732|
0006c4  444d3930          DCB      "DM9000: MAC Address: %u:%u:%u:%u:%u:%u\r\n",0
0006c8  30303a20
0006cc  4d414320
0006d0  41646472
0006d4  6573733a
0006d8  2025753a
0006dc  25753a25
0006e0  753a2575
0006e4  3a25753a
0006e8  25750d0a
0006ec  00      
0006ed  00                DCB      0
0006ee  00                DCB      0
0006ef  00                DCB      0
                  |L1.1776|
0006f0  6c696e6b          DCB      "link stauts = %x\r\n",0
0006f4  20737461
0006f8  75747320
0006fc  3d202578
000700  0d0a00  
000703  00                DCB      0
                  |L1.1796|
000704  494e464f          DCB      "INFO: Init: DM9000_Init OK.\r\n",0
000708  3a20496e
00070c  69743a20
000710  444d3930
000714  30305f49
000718  6e697420
00071c  4f4b2e0d
000720  0a00    
000722  00                DCB      0
000723  00                DCB      0
                          ENDP

                  DM9000DBG_GetPendingInts PROC
;;;348    UINT32T
;;;349    DM9000DBG_GetPendingInts(void)
000724  e92d4010          PUSH     {r4,lr}
;;;350    {
;;;351     UINT8T intr_state;
;;;352     
;;;353     intr_state = READ_REG1(0xfe);
000728  e3a000fe          MOV      r0,#0xfe
00072c  ebfffffe          BL       ReadReg
000730  e1a04000          MOV      r4,r0
;;;354     WRITE_REG1(0xfe, intr_state); /*clean ISR*/
000734  e1a01004          MOV      r1,r4
000738  e3a000fe          MOV      r0,#0xfe
00073c  ebfffffe          BL       WriteReg
;;;355     return(1);
000740  e3a00001          MOV      r0,#1
000744  e8bd4010          POP      {r4,lr}
;;;356    
;;;357    }
000748  e12fff1e          BX       lr
;;;358    
                          ENDP

                  DM9000DBG_GetFrame PROC
;;;361    /*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
;;;362    int DM9000DBG_GetFrame(UINT8T *pbData,  unsigned int *pwLength)
00074c  e92d4ff8          PUSH     {r3-r11,lr}
;;;363    {
000750  e1a08000          MOV      r8,r0
000754  e1a0a001          MOV      r10,r1
;;;364     
;;;365     int i;
;;;366     unsigned long tmp32;
;;;367     unsigned short rxlen, tmplen;
;;;368     unsigned short status;
;;;369     UINT8T RxRead;
;;;370    
;;;371     RxRead=READ_REG1(0xFE);
000758  e3a000fe          MOV      r0,#0xfe
00075c  ebfffffe          BL       ReadReg
000760  e1a0b000          MOV      r11,r0
;;;372     if(RxRead&0x01==0) return -1;
000764  e3a00000          MOV      r0,#0
000768  e3500000          CMP      r0,#0
00076c  0a000002          BEQ      |L1.1916|
000770  e3e00000          MVN      r0,#0
                  |L1.1908|
000774  e8bd4ff8          POP      {r3-r11,lr}
;;;373    
;;;374     READ_REG1(0x3); 
;;;375    
;;;376     READ_REG1(0x4);  /*Try & work run*/
;;;377     
;;;378     /* read the first byte*/
;;;379     RxRead = READ_REG1(0xf0);
;;;380     RxRead = IOREAD(dwEthernetDataPort);
;;;381     RxRead = IOREAD(dwEthernetDataPort);
;;;382    
;;;383     /* the fist byte is ready or not */
;;;384     if ((RxRead & 3) != 1)  /* no data */
;;;385     	{
;;;386        return -1;
;;;387    	}																			    
;;;388     IOWRITE(dwEthernetIOBase, 0xf2); /* set read ptr ++ */
;;;389     switch (DM9000_iomode)
;;;390     {
;;;391      case DM9000_BYTE_MODE:
;;;392       status = IOREAD(dwEthernetDataPort)+(IOREAD(dwEthernetDataPort)<<8);
;;;393       rxlen = IOREAD(dwEthernetDataPort) + (IOREAD(dwEthernetDataPort)<<8);
;;;394       break;
;;;395      case DM9000_WORD_MODE:
;;;396       status = IOREAD16(dwEthernetDataPort);  
;;;397       rxlen = IOREAD16(dwEthernetDataPort);  
;;;398       break;
;;;399      case DM9000_DWORD_MODE:
;;;400       tmp32 = IOREAD32(dwEthernetDataPort);
;;;401       status = (unsigned short)(tmp32&0xffff);
;;;402       rxlen = (unsigned short)((tmp32>>16)&0xffff);
;;;403      default:
;;;404       uart_printf("[DM9000]Get status and rxlen error!!!");
;;;405       break;
;;;406     }  
;;;407    
;;;408     if (status & 0xbf00)
;;;409      uart_printf("[DM9000]RX status error!!!=[%x]",(status>>8) );
;;;410    
;;;411     /* move data from FIFO to memory */
;;;412     switch (DM9000_iomode)
;;;413     {
;;;414      case DM9000_BYTE_MODE:
;;;415       tmplen = rxlen ;
;;;416       for (i = 0; i < tmplen; i++)
;;;417        ((UINT8T *)pbData)[i] = IOREAD(dwEthernetDataPort);
;;;418       break;
;;;419      case DM9000_WORD_MODE:
;;;420       tmplen = (rxlen+1)/2;
;;;421       for (i = 0; i < tmplen; i++)
;;;422        ((UINT16T *)pbData)[i] = IOREAD16(dwEthernetDataPort);
;;;423       break;
;;;424      case DM9000_DWORD_MODE:
;;;425       tmplen = (rxlen+3)/4;
;;;426       for (i = 0; i < tmplen; i++)
;;;427        ((UINT32T *)pbData)[i] = IOREAD32(dwEthernetDataPort);
;;;428      default:
;;;429       uart_printf("[DM9000][RX]Move data error!!!");
;;;430       break;
;;;431     }
;;;432    
;;;433     *pwLength = rxlen;
;;;434     /* clean ISR */
;;;435     WRITE_REG1(0xfe,READ_REG1(0xfe));
;;;436     return rxlen; 
;;;437    }
000778  e12fff1e          BX       lr
                  |L1.1916|
00077c  e3a00003          MOV      r0,#3                 ;374
000780  ebfffffe          BL       ReadReg
000784  e3a00004          MOV      r0,#4                 ;376
000788  ebfffffe          BL       ReadReg
00078c  e3a000f0          MOV      r0,#0xf0              ;379
000790  ebfffffe          BL       ReadReg
000794  e1a0b000          MOV      r11,r0                ;379
000798  e51f04dc          LDR      r0,|L1.708|
00079c  e5900000          LDR      r0,[r0,#0]            ;380  ; dwEthernetDataPort
0007a0  e5d0b000          LDRB     r11,[r0,#0]           ;380
0007a4  e51f04e8          LDR      r0,|L1.708|
0007a8  e5900000          LDR      r0,[r0,#0]            ;381  ; dwEthernetDataPort
0007ac  e5d0b000          LDRB     r11,[r0,#0]           ;381
0007b0  e20b0003          AND      r0,r11,#3             ;384
0007b4  e3500001          CMP      r0,#1                 ;384
0007b8  0a000001          BEQ      |L1.1988|
0007bc  e3e00000          MVN      r0,#0                 ;386
0007c0  eaffffeb          B        |L1.1908|
                  |L1.1988|
0007c4  e3a000f2          MOV      r0,#0xf2              ;388
0007c8  e51f1510          LDR      r1,|L1.704|
0007cc  e5911000          LDR      r1,[r1,#0]            ;388  ; dwEthernetIOBase
0007d0  e5c10000          STRB     r0,[r1,#0]            ;388
0007d4  e51f0144          LDR      r0,|L1.1688|
0007d8  e5d00000          LDRB     r0,[r0,#0]            ;389  ; DM9000_iomode
0007dc  e3500000          CMP      r0,#0                 ;389
0007e0  0a000014          BEQ      |L1.2104|
0007e4  e3500001          CMP      r0,#1                 ;389
0007e8  0a00001a          BEQ      |L1.2136|
0007ec  e3500002          CMP      r0,#2                 ;389
0007f0  1a000021          BNE      |L1.2172|
0007f4  e51f0538          LDR      r0,|L1.708|
0007f8  e5900000          LDR      r0,[r0,#0]            ;392  ; dwEthernetDataPort
0007fc  e5d00000          LDRB     r0,[r0,#0]            ;392
000800  e51f1544          LDR      r1,|L1.708|
000804  e5911000          LDR      r1,[r1,#0]            ;392  ; dwEthernetDataPort
000808  e5d11000          LDRB     r1,[r1,#0]            ;392
00080c  e0800401          ADD      r0,r0,r1,LSL #8       ;392
000810  e3c07801          BIC      r7,r0,#0x10000        ;392
000814  e51f0558          LDR      r0,|L1.708|
000818  e5900000          LDR      r0,[r0,#0]            ;393  ; dwEthernetDataPort
00081c  e5d00000          LDRB     r0,[r0,#0]            ;393
000820  e51f1564          LDR      r1,|L1.708|
000824  e5911000          LDR      r1,[r1,#0]            ;393  ; dwEthernetDataPort
000828  e5d11000          LDRB     r1,[r1,#0]            ;393
00082c  e0800401          ADD      r0,r0,r1,LSL #8       ;393
000830  e3c05801          BIC      r5,r0,#0x10000        ;393
000834  ea000013          B        |L1.2184|
                  |L1.2104|
000838  e1a00000          MOV      r0,r0                 ;395
00083c  e51f0580          LDR      r0,|L1.708|
000840  e5900000          LDR      r0,[r0,#0]            ;396  ; dwEthernetDataPort
000844  e1d070b0          LDRH     r7,[r0,#0]            ;396
000848  e51f058c          LDR      r0,|L1.708|
00084c  e5900000          LDR      r0,[r0,#0]            ;397  ; dwEthernetDataPort
000850  e1d050b0          LDRH     r5,[r0,#0]            ;397
000854  ea00000b          B        |L1.2184|
                  |L1.2136|
000858  e1a00000          MOV      r0,r0                 ;399
00085c  e51f05a0          LDR      r0,|L1.708|
000860  e5900000          LDR      r0,[r0,#0]            ;400  ; dwEthernetDataPort
000864  e5909000          LDR      r9,[r0,#0]            ;400
000868  e1a07809          LSL      r7,r9,#16             ;401
00086c  e1a07827          LSR      r7,r7,#16             ;401
000870  e59f0220          LDR      r0,|L1.2712|
000874  e0005829          AND      r5,r0,r9,LSR #16      ;402
000878  e1a00000          MOV      r0,r0                 ;403
                  |L1.2172|
00087c  e28f0f86          ADR      r0,|L1.2716|
000880  ebfffffe          BL       uart_printf
000884  e1a00000          MOV      r0,r0                 ;405
                  |L1.2184|
000888  e1a00000          MOV      r0,r0                 ;394
00088c  e3170cbf          TST      r7,#0xbf00            ;408
000890  0a000002          BEQ      |L1.2208|
000894  e1a01447          ASR      r1,r7,#8              ;409
000898  e28f0f89          ADR      r0,|L1.2756|
00089c  ebfffffe          BL       uart_printf
                  |L1.2208|
0008a0  e51f0210          LDR      r0,|L1.1688|
0008a4  e5d00000          LDRB     r0,[r0,#0]            ;412  ; DM9000_iomode
0008a8  e3500000          CMP      r0,#0                 ;412
0008ac  0a00000e          BEQ      |L1.2284|
0008b0  e3500001          CMP      r0,#1                 ;412
0008b4  0a00001c          BEQ      |L1.2348|
0008b8  e3500002          CMP      r0,#2                 ;412
0008bc  1a00002a          BNE      |L1.2412|
0008c0  e1a06005          MOV      r6,r5                 ;415
0008c4  e3a04000          MOV      r4,#0                 ;416
0008c8  ea000004          B        |L1.2272|
                  |L1.2252|
0008cc  e51f0610          LDR      r0,|L1.708|
0008d0  e5900000          LDR      r0,[r0,#0]            ;417  ; dwEthernetDataPort
0008d4  e5d00000          LDRB     r0,[r0,#0]            ;417
0008d8  e7c80004          STRB     r0,[r8,r4]            ;417
0008dc  e2844001          ADD      r4,r4,#1              ;416
                  |L1.2272|
0008e0  e1540006          CMP      r4,r6                 ;416
0008e4  bafffff8          BLT      |L1.2252|
0008e8  ea000022          B        |L1.2424|
                  |L1.2284|
0008ec  e1a00000          MOV      r0,r0                 ;419
0008f0  e2850001          ADD      r0,r5,#1              ;420
0008f4  e0801fa0          ADD      r1,r0,r0,LSR #31      ;420
0008f8  e1a01781          LSL      r1,r1,#15             ;420
0008fc  e1a06821          LSR      r6,r1,#16             ;420
000900  e3a04000          MOV      r4,#0                 ;421
000904  ea000005          B        |L1.2336|
                  |L1.2312|
000908  e51f064c          LDR      r0,|L1.708|
00090c  e5900000          LDR      r0,[r0,#0]            ;422  ; dwEthernetDataPort
000910  e1d000b0          LDRH     r0,[r0,#0]            ;422
000914  e0881084          ADD      r1,r8,r4,LSL #1       ;422
000918  e1c100b0          STRH     r0,[r1,#0]            ;422
00091c  e2844001          ADD      r4,r4,#1              ;421
                  |L1.2336|
000920  e1540006          CMP      r4,r6                 ;421
000924  bafffff7          BLT      |L1.2312|
000928  ea000012          B        |L1.2424|
                  |L1.2348|
00092c  e1a00000          MOV      r0,r0                 ;424
000930  e2850003          ADD      r0,r5,#3              ;425
000934  e1a01fc0          ASR      r1,r0,#31             ;425
000938  e0801f21          ADD      r1,r0,r1,LSR #30      ;425
00093c  e1a01701          LSL      r1,r1,#14             ;425
000940  e1a06821          LSR      r6,r1,#16             ;425
000944  e3a04000          MOV      r4,#0                 ;426
000948  ea000004          B        |L1.2400|
                  |L1.2380|
00094c  e51f0690          LDR      r0,|L1.708|
000950  e5900000          LDR      r0,[r0,#0]            ;427  ; dwEthernetDataPort
000954  e5900000          LDR      r0,[r0,#0]            ;427
000958  e7880104          STR      r0,[r8,r4,LSL #2]     ;427
00095c  e2844001          ADD      r4,r4,#1              ;426
                  |L1.2400|
000960  e1540006          CMP      r4,r6                 ;426
000964  bafffff8          BLT      |L1.2380|
000968  e1a00000          MOV      r0,r0                 ;428
                  |L1.2412|
00096c  e28f0e17          ADR      r0,|L1.2788|
000970  ebfffffe          BL       uart_printf
000974  e1a00000          MOV      r0,r0                 ;430
                  |L1.2424|
000978  e1a00000          MOV      r0,r0                 ;418
00097c  e58a5000          STR      r5,[r10,#0]           ;433
000980  e3a000fe          MOV      r0,#0xfe              ;435
000984  ebfffffe          BL       ReadReg
000988  e58d0000          STR      r0,[sp,#0]            ;435
00098c  e1a01000          MOV      r1,r0                 ;435
000990  e3a000fe          MOV      r0,#0xfe              ;435
000994  ebfffffe          BL       WriteReg
000998  e1a00005          MOV      r0,r5                 ;436
00099c  eaffff74          B        |L1.1908|
;;;438    
                          ENDP

                  DM9000DBG_SendFrame PROC
;;;442    /*::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::*/
;;;443    UINT16T DM9000DBG_SendFrame( UINT8T *pbData, UINT32T dwLength )
0009a0  e92d4070          PUSH     {r4-r6,lr}
;;;444    {
0009a4  e1a05000          MOV      r5,r0
0009a8  e1a04001          MOV      r4,r1
;;;445    // uart_printf("[DM9000A]: DM9000DBG_SendFrame()..........\r\n");
;;;446     return dm9000_send(pbData, (UINT16T)dwLength);
0009ac  e1a01804          LSL      r1,r4,#16
0009b0  e1a01821          LSR      r1,r1,#16
0009b4  e1a00005          MOV      r0,r5
0009b8  ebfffffe          BL       dm9000_send
0009bc  e1a00800          LSL      r0,r0,#16
0009c0  e1a00820          LSR      r0,r0,#16
0009c4  e8bd4070          POP      {r4-r6,lr}
;;;447    }
0009c8  e12fff1e          BX       lr
;;;448    
                          ENDP

                  DM9000DBG_CurrentPacketFilter PROC
;;;455    */
;;;456    void DM9000DBG_CurrentPacketFilter(UINT32T dwFilter)
0009cc  e92d41f0          PUSH     {r4-r8,lr}
;;;457    {
0009d0  e1a04000          MOV      r4,r0
;;;458     UINT8T uTemp;
;;;459     UINT16T i, oft;
;;;460    
;;;461     uart_printf("[DM9000A]: DM9000DBG_CurrentPacketFilter()..........\r\n");  
0009d4  e28f0f4a          ADR      r0,|L1.2820|
0009d8  ebfffffe          BL       uart_printf
;;;462     // What kind of filtering do we want to apply?
;;;463     //
;;;464     // NOTE: the filter provided might be 0, but since this EDBG driver is used for KITL, we don't want
;;;465     // to stifle the KITL connection, so broadcast and directed packets should always be accepted.
;;;466     //
;;;467     if (dwFilter & PACKET_TYPE_ALL_MULTICAST)
0009dc  e3140004          TST      r4,#4
0009e0  0a000005          BEQ      |L1.2556|
;;;468     { // Accept *all* multicast packets.
;;;469      uTemp = READ_REG1(0x05);
0009e4  e3a00005          MOV      r0,#5
0009e8  ebfffffe          BL       ReadReg
0009ec  e1a06000          MOV      r6,r0
;;;470      WRITE_REG1(0x05, uTemp | 0x08);  //Enable pass all multicast
0009f0  e3861008          ORR      r1,r6,#8
0009f4  e3a00005          MOV      r0,#5
0009f8  ebfffffe          BL       WriteReg
                  |L1.2556|
;;;471     }
;;;472    
;;;473    #if 0  //Always can receive multicast address according to hash table.
;;;474     if (dwFilter & PACKET_TYPE_MULTICAST)
;;;475     { // Accept multicast packets.
;;;476      
;;;477     }
;;;478    #endif
;;;479    
;;;480     if (dwFilter & PACKET_TYPE_BROADCAST)
0009fc  e3140008          TST      r4,#8
000a00  0a000017          BEQ      |L1.2660|
;;;481     {
;;;482      /* broadcast address */
;;;483      hash_table[3] = 0x8000;
000a04  e3a00902          MOV      r0,#0x8000
000a08  e51f1730          LDR      r1,|L1.736|
000a0c  e1c100b6          STRH     r0,[r1,#6]  ; hash_table
;;;484      /* Write the hash table to MAC MD table */
;;;485      for (i = 0, oft = 0x16; i < 4; i++) {
000a10  e3a05000          MOV      r5,#0
000a14  e3a07016          MOV      r7,#0x16
000a18  ea00000f          B        |L1.2652|
                  |L1.2588|
;;;486       WRITE_REG1(oft++, hash_table[i] & 0xff);
000a1c  e51f2744          LDR      r2,|L1.736|
000a20  e7d21085          LDRB     r1,[r2,r5,LSL #1]
000a24  e1a00007          MOV      r0,r7
000a28  e2873001          ADD      r3,r7,#1
000a2c  e3c37801          BIC      r7,r3,#0x10000
000a30  ebfffffe          BL       WriteReg
;;;487       WRITE_REG1(oft++, (hash_table[i] >> 8) & 0xff);
000a34  e51f275c          LDR      r2,|L1.736|
000a38  e0822085          ADD      r2,r2,r5,LSL #1
000a3c  e1d220b0          LDRH     r2,[r2,#0]
000a40  e1a01442          ASR      r1,r2,#8
000a44  e1a00007          MOV      r0,r7
000a48  e2873001          ADD      r3,r7,#1
000a4c  e3c37801          BIC      r7,r3,#0x10000
000a50  ebfffffe          BL       WriteReg
000a54  e2850001          ADD      r0,r5,#1              ;485
000a58  e3c05801          BIC      r5,r0,#0x10000        ;485
                  |L1.2652|
000a5c  e3550004          CMP      r5,#4                 ;485
000a60  baffffed          BLT      |L1.2588|
                  |L1.2660|
;;;488      }
;;;489      
;;;490     }
;;;491     
;;;492     // Promiscuous mode is causing random hangs - it's not strictly needed.
;;;493     if (dwFilter & PACKET_TYPE_PROMISCUOUS)
000a64  e3140020          TST      r4,#0x20
000a68  0a000005          BEQ      |L1.2692|
;;;494     { // Accept anything.
;;;495      uTemp = READ_REG1(0x05);
000a6c  e3a00005          MOV      r0,#5
000a70  ebfffffe          BL       ReadReg
000a74  e1a06000          MOV      r6,r0
;;;496      WRITE_REG1(0x05, uTemp | 0x02);  //Enable pass all multicast
000a78  e3861002          ORR      r1,r6,#2
000a7c  e3a00005          MOV      r0,#5
000a80  ebfffffe          BL       WriteReg
                  |L1.2692|
;;;497     }
;;;498    
;;;499        uart_printf("DM9000: Set receive packet filter [Filter=0x%x].\r\n", dwFilter);
000a84  e1a01004          MOV      r1,r4
000a88  e28f00ac          ADR      r0,|L1.2876|
000a8c  ebfffffe          BL       uart_printf
;;;500    
;;;501    
;;;502    } // DM9000DBG_CurrentPacketFilter().
000a90  e8bd41f0          POP      {r4-r8,lr}
000a94  e12fff1e          BX       lr
                  |L1.2712|
                          DCD      0x0000ffff
                  |L1.2716|
000a9c  5b444d39          DCB      "[DM9000]Get status and rxlen error!!!",0
000aa0  3030305d
000aa4  47657420
000aa8  73746174
000aac  75732061
000ab0  6e642072
000ab4  786c656e
000ab8  20657272
000abc  6f722121
000ac0  2100    
000ac2  00                DCB      0
000ac3  00                DCB      0
                  |L1.2756|
000ac4  5b444d39          DCB      "[DM9000]RX status error!!!=[%x]",0
000ac8  3030305d
000acc  52582073
000ad0  74617475
000ad4  73206572
000ad8  726f7221
000adc  21213d5b
000ae0  25785d00
                  |L1.2788|
000ae4  5b444d39          DCB      "[DM9000][RX]Move data error!!!",0
000ae8  3030305d
000aec  5b52585d
000af0  4d6f7665
000af4  20646174
000af8  61206572
000afc  726f7221
000b00  212100  
000b03  00                DCB      0
                  |L1.2820|
000b04  5b444d39          DCB      "[DM9000A]: DM9000DBG_CurrentPacketFilter()..........\r\n"
000b08  30303041
000b0c  5d3a2044
000b10  4d393030
000b14  30444247
000b18  5f437572
000b1c  72656e74
000b20  5061636b
000b24  65744669
000b28  6c746572
000b2c  28292e2e
000b30  2e2e2e2e
000b34  2e2e2e2e
000b38  0d0a    
000b3a  00                DCB      0
000b3b  00                DCB      0
                  |L1.2876|
000b3c  444d3930          DCB      "DM9000: Set receive packet filter [Filter=0x%x].\r\n",0
000b40  30303a20
000b44  53657420
000b48  72656365
000b4c  69766520
000b50  7061636b
000b54  65742066
000b58  696c7465
000b5c  72205b46
000b60  696c7465
000b64  723d3078
000b68  25785d2e
000b6c  0d0a00  
000b6f  00                DCB      0
                          ENDP

                  DM9000DBG_MulticastList PROC
;;;510    */
;;;511    int DM9000DBG_MulticastList(UINT8T *pucMulticastAddresses, UINT32T dwNumAddresses)
000b70  e92d47f0          PUSH     {r4-r10,lr}
;;;512    {
000b74  e24dd018          SUB      sp,sp,#0x18
000b78  e1a06000          MOV      r6,r0
000b7c  e1a08001          MOV      r8,r1
;;;513     UINT8T nCount;
;;;514     UINT8T nIndex;
;;;515     UINT8T i, oft;
;;;516     UINT8T Reg5;
;;;517    
;;;518     //Stop RX
;;;519     Reg5 = READ_REG1(0x05);
000b80  e3a00005          MOV      r0,#5
000b84  ebfffffe          BL       ReadReg
000b88  e1a0a000          MOV      r10,r0
;;;520     WRITE_REG1(0x05, Reg5 & 0xfe);
000b8c  e20a10fe          AND      r1,r10,#0xfe
000b90  e3a00005          MOV      r0,#5
000b94  ebfffffe          BL       WriteReg
;;;521    
;;;522     // Compute the logical address filter value.
;;;523     //
;;;524     for (nCount = 0 ; nCount < dwNumAddresses ; nCount++)
000b98  e3a05000          MOV      r5,#0
000b9c  ea000036          B        |L1.3196|
                  |L1.2976|
;;;525     {
;;;526             uart_printf("DM9000: Multicast[%d of %d]  = %x-%x-%x-%x-%x-%x\r\n",
000ba0  e0850085          ADD      r0,r5,r5,LSL #1
000ba4  e1a00080          LSL      r0,r0,#1
000ba8  e2800005          ADD      r0,r0,#5
000bac  e7d60000          LDRB     r0,[r6,r0]
000bb0  e0851085          ADD      r1,r5,r5,LSL #1
000bb4  e1a01081          LSL      r1,r1,#1
000bb8  e2811004          ADD      r1,r1,#4
000bbc  e7d61001          LDRB     r1,[r6,r1]
000bc0  e0852085          ADD      r2,r5,r5,LSL #1
000bc4  e1a02082          LSL      r2,r2,#1
000bc8  e2822003          ADD      r2,r2,#3
000bcc  e7d62002          LDRB     r2,[r6,r2]
000bd0  e0853085          ADD      r3,r5,r5,LSL #1
000bd4  e1a03083          LSL      r3,r3,#1
000bd8  e2833002          ADD      r3,r3,#2
000bdc  e7d63003          LDRB     r3,[r6,r3]
000be0  e58d0010          STR      r0,[sp,#0x10]
000be4  e0850085          ADD      r0,r5,r5,LSL #1
000be8  e1a00080          LSL      r0,r0,#1
000bec  e2800001          ADD      r0,r0,#1
000bf0  e58d100c          STR      r1,[sp,#0xc]
000bf4  e58d2008          STR      r2,[sp,#8]
000bf8  e58d3004          STR      r3,[sp,#4]
000bfc  e7d60000          LDRB     r0,[r6,r0]
000c00  e58d0000          STR      r0,[sp,#0]
000c04  e0850085          ADD      r0,r5,r5,LSL #1
000c08  e7d63080          LDRB     r3,[r6,r0,LSL #1]
000c0c  e1a02008          MOV      r2,r8
000c10  e2851001          ADD      r1,r5,#1
000c14  e28f0e12          ADR      r0,|L1.3388|
000c18  ebfffffe          BL       uart_printf
;;;527                                 (nCount + 1),
;;;528            dwNumAddresses,
;;;529                                 pucMulticastAddresses[6*nCount + 0],
;;;530                                 pucMulticastAddresses[6*nCount + 1],
;;;531                                 pucMulticastAddresses[6*nCount + 2],
;;;532                                 pucMulticastAddresses[6*nCount + 3],
;;;533                                 pucMulticastAddresses[6*nCount + 4],
;;;534                                 pucMulticastAddresses[6*nCount + 5]);
;;;535    
;;;536      nIndex = CalculateHashIndex(&pucMulticastAddresses[6*nCount]);
000c1c  e3a01006          MOV      r1,#6
000c20  e0206591          MLA      r0,r1,r5,r6
000c24  ebfffffe          BL       CalculateHashIndex
000c28  e1a04000          MOV      r4,r0
;;;537             hash_table[nIndex/16]  |=  1 << (nIndex%16);
000c2c  e1a02fc4          ASR      r2,r4,#31
000c30  e0842e22          ADD      r2,r4,r2,LSR #28
000c34  e1a02242          ASR      r2,r2,#4
000c38  e51f3960          LDR      r3,|L1.736|
000c3c  e0832082          ADD      r2,r3,r2,LSL #1
000c40  e1d220b0          LDRH     r2,[r2,#0]
000c44  e1a03fc4          ASR      r3,r4,#31
000c48  e0843e23          ADD      r3,r4,r3,LSR #28
000c4c  e1a03243          ASR      r3,r3,#4
000c50  e0443203          SUB      r3,r4,r3,LSL #4
000c54  e3a0c001          MOV      r12,#1
000c58  e182231c          ORR      r2,r2,r12,LSL r3
000c5c  e1a03fc4          ASR      r3,r4,#31
000c60  e0843e23          ADD      r3,r4,r3,LSR #28
000c64  e1a03243          ASR      r3,r3,#4
000c68  e51fc990          LDR      r12,|L1.736|
000c6c  e08c3083          ADD      r3,r12,r3,LSL #1
000c70  e1c320b0          STRH     r2,[r3,#0]
000c74  e2850001          ADD      r0,r5,#1              ;524
000c78  e20050ff          AND      r5,r0,#0xff           ;524
                  |L1.3196|
000c7c  e1550008          CMP      r5,r8                 ;524
000c80  3affffc6          BCC      |L1.2976|
;;;538     }
;;;539    
;;;540     uart_printf("DM9000: Logical Address Filter = %x.%x.%x.%x.\r\n", hash_table[3], hash_table[2], hash_table[1], hash_table[0]);
000c84  e51f09ac          LDR      r0,|L1.736|
000c88  e1d000b0          LDRH     r0,[r0,#0]  ; hash_table
000c8c  e58d0000          STR      r0,[sp,#0]
000c90  e51f09b8          LDR      r0,|L1.736|
000c94  e1d030b2          LDRH     r3,[r0,#2]  ; hash_table
000c98  e1d020b4          LDRH     r2,[r0,#4]  ; hash_table
000c9c  e1d010b6          LDRH     r1,[r0,#6]  ; hash_table
000ca0  e28f00c8          ADR      r0,|L1.3440|
000ca4  ebfffffe          BL       uart_printf
;;;541     
;;;542     /* Write the hash table to MAC MD table */
;;;543     for (i = 0, oft = 0x16; i < 4; i++) {
000ca8  e3a07000          MOV      r7,#0
000cac  e3a09016          MOV      r9,#0x16
000cb0  ea00000f          B        |L1.3316|
                  |L1.3252|
;;;544      WRITE_REG1(oft++, hash_table[i] & 0xff);
000cb4  e51f29dc          LDR      r2,|L1.736|
000cb8  e7d21087          LDRB     r1,[r2,r7,LSL #1]
000cbc  e1a00009          MOV      r0,r9
000cc0  e2893001          ADD      r3,r9,#1
000cc4  e20390ff          AND      r9,r3,#0xff
000cc8  ebfffffe          BL       WriteReg
;;;545      WRITE_REG1(oft++, (hash_table[i] >> 8) & 0xff);
000ccc  e51f29f4          LDR      r2,|L1.736|
000cd0  e0822087          ADD      r2,r2,r7,LSL #1
000cd4  e1d220b0          LDRH     r2,[r2,#0]
000cd8  e1a01442          ASR      r1,r2,#8
000cdc  e1a00009          MOV      r0,r9
000ce0  e2893001          ADD      r3,r9,#1
000ce4  e20390ff          AND      r9,r3,#0xff
000ce8  ebfffffe          BL       WriteReg
000cec  e2870001          ADD      r0,r7,#1              ;543
000cf0  e20070ff          AND      r7,r0,#0xff           ;543
                  |L1.3316|
000cf4  e3570004          CMP      r7,#4                 ;543
000cf8  baffffed          BLT      |L1.3252|
;;;546     }
;;;547    
;;;548     //Start RX
;;;549     WRITE_REG1(0x05, Reg5);
000cfc  e1a0100a          MOV      r1,r10
000d00  e3a00005          MOV      r0,#5
000d04  ebfffffe          BL       WriteReg
;;;550     
;;;551        return(TRUE);
000d08  e3a00001          MOV      r0,#1
000d0c  e28dd018          ADD      sp,sp,#0x18
000d10  e8bd47f0          POP      {r4-r10,lr}
;;;552    
;;;553    } // DM9000DBG_MulticastList
000d14  e12fff1e          BX       lr
;;;554    
                          ENDP

                  board_eth_get_addr PROC
;;;555     int board_eth_get_addr(unsigned char *addr)
000d18  e92d4010          PUSH     {r4,lr}
;;;556    {
000d1c  e1a04000          MOV      r4,r0
;;;557    	memcpy(addr, OurEmacAddr, 6);
000d20  e3a02006          MOV      r2,#6
000d24  e59f1074          LDR      r1,|L1.3488|
000d28  e1a00004          MOV      r0,r4
000d2c  ebfffffe          BL       memcpy
;;;558    	return 0;
000d30  e3a00000          MOV      r0,#0
000d34  e8bd4010          POP      {r4,lr}
;;;559    }
000d38  e12fff1e          BX       lr
                          ENDP

                  |L1.3388|
000d3c  444d3930          DCB      "DM9000: Multicast[%d of %d]  = %x-%x-%x-%x-%x-%x\r\n",0
000d40  30303a20
000d44  4d756c74
000d48  69636173
000d4c  745b2564
000d50  206f6620
000d54  25645d20
000d58  203d2025
000d5c  782d2578
000d60  2d25782d
000d64  25782d25
000d68  782d2578
000d6c  0d0a00  
000d6f  00                DCB      0
                  |L1.3440|
000d70  444d3930          DCB      "DM9000: Logical Address Filter = %x.%x.%x.%x.\r\n",0
000d74  30303a20
000d78  4c6f6769
000d7c  63616c20
000d80  41646472
000d84  65737320
000d88  46696c74
000d8c  6572203d
000d90  2025782e
000d94  25782e25
000d98  782e2578
000d9c  2e0d0a00
                  |L1.3488|
                          DCD      OurEmacAddr

                          AREA ||.data||, DATA, ALIGN=2

                  MacAddr
000000  80001248          DCW      0x8000,0x1248
000004  5634              DCW      0x5634
                  OurEmacAddr
000006  0000              DCB      0x00,0x00
000008  32123312          DCB      0x32,0x12,0x33,0x12
                  dwEthernetIOBase
                          DCD      0x00000000
                  dwEthernetDataPort
                          DCD      0x00000000
                  DM9000_iomode
000014  0000              DCB      0x00,0x00
                  hash_table
000016  0000              DCB      0x00,0x00
                          DCD      0x00000000
00001c  0000              DCB      0x00,0x00
                  DM9000_rev
00001e  00                DCB      0x00

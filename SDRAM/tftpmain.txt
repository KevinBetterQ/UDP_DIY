; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\SDRAM\tftpmain.o --asm_dir=.\SDRAM\ --list_dir=.\SDRAM\ --depend=.\SDRAM\tftpmain.d --cpu=ARM920T --apcs=interwork -O0 -I..\Common\Inc -I.\INC -I.\INC\tftp -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Samsung --omf_browse=.\SDRAM\tftpmain.crf Source\tftp\tftpmain.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  ntohs PROC
;;;3      
;;;4      unsigned short ntohs(unsigned short s)
000000  e1a01000          MOV      r1,r0
;;;5      {
;;;6      	return (s >> 8) | (s << 8);
000004  e1a00441          ASR      r0,r1,#8
000008  e1800401          ORR      r0,r0,r1,LSL #8
00000c  e3c008ff          BIC      r0,r0,#0xff0000
;;;7      }
000010  e12fff1e          BX       lr
;;;8      
                          ENDP

                  ntohl PROC
;;;9      unsigned long ntohl(unsigned long l)
000014  e1a01000          MOV      r1,r0
;;;10     {
;;;11     	return  ((l >> 24) & 0x000000ff) |
000018  e3a02cff          MOV      r2,#0xff00
00001c  e0022421          AND      r2,r2,r1,LSR #8
000020  e1820c21          ORR      r0,r2,r1,LSR #24
000024  e3a028ff          MOV      r2,#0xff0000
000028  e0022401          AND      r2,r2,r1,LSL #8
00002c  e1800002          ORR      r0,r0,r2
000030  e3a024ff          MOV      r2,#0xff000000
000034  e0022c01          AND      r2,r2,r1,LSL #24
000038  e1800002          ORR      r0,r0,r2
;;;12     		((l >>  8) & 0x0000ff00) |
;;;13     		((l <<  8) & 0x00ff0000) |
;;;14     		((l << 24) & 0xff000000);
;;;15     }
00003c  e12fff1e          BX       lr
;;;16     
                          ENDP

                  htons PROC
;;;17     unsigned short htons(unsigned short s)
000040  e1a01000          MOV      r1,r0
;;;18     {
;;;19     	return (s >> 8) | (s << 8);
000044  e1a00441          ASR      r0,r1,#8
000048  e1800401          ORR      r0,r0,r1,LSL #8
00004c  e3c008ff          BIC      r0,r0,#0xff0000
;;;20     }
000050  e12fff1e          BX       lr
;;;21     
                          ENDP

                  htonl PROC
;;;22     unsigned long htonl(unsigned long l)
000054  e52de004          PUSH     {lr}
;;;23     {
000058  e1a03000          MOV      r3,r0
;;;24     	return ntohl(l);
00005c  e1a00003          MOV      r0,r3
000060  ebfffffe          BL       ntohl
000064  e49de004          POP      {lr}
;;;25     }
000068  e12fff1e          BX       lr
;;;26     
                          ENDP

                  net_handle PROC
;;;15     
;;;16     int net_handle(void)
00006c  e92d4070          PUSH     {r4-r6,lr}
;;;17     {
;;;18     	struct sk_buff *skb;
;;;19     	struct ethhdr *eth_hdr;												
;;;20     	skb = alloc_skb(ETH_FRAME_LEN);
000070  e59f0200          LDR      r0,|L1.632|
000074  ebfffffe          BL       alloc_skb
000078  e1a05000          MOV      r5,r0
;;;21     
;;;22     	if (eth_rcv(skb) != -1) 
00007c  e1a00005          MOV      r0,r5
000080  ebfffffe          BL       eth_rcv
000084  e3700001          CMN      r0,#1
000088  0a000015          BEQ      |L1.228|
;;;23     	{
;;;24     
;;;25     		eth_hdr = (struct ethhdr *)(skb->data);					
00008c  e59545f0          LDR      r4,[r5,#0x5f0]
;;;26     		skb_pull(skb, ETH_HLEN);
000090  e3a0100e          MOV      r1,#0xe
000094  e1a00005          MOV      r0,r5
000098  ebfffffe          BL       skb_pull
;;;27     		if (ntohs(eth_hdr->h_proto) == ETH_P_ARP)
00009c  e5d4100d          LDRB     r1,[r4,#0xd]
0000a0  e5d4200c          LDRB     r2,[r4,#0xc]
0000a4  e1820401          ORR      r0,r2,r1,LSL #8
0000a8  ebfffffe          BL       ntohs
0000ac  e2401b02          SUB      r1,r0,#0x800
0000b0  e2511006          SUBS     r1,r1,#6
0000b4  1a000002          BNE      |L1.196|
;;;28     		{
;;;29     			arp_rcv_packet(skb);
0000b8  e1a00005          MOV      r0,r5
0000bc  ebfffffe          BL       arp_rcv_packet
0000c0  ea000007          B        |L1.228|
                  |L1.196|
;;;30     
;;;31     		}
;;;32     
;;;33     		else if(ntohs(eth_hdr->h_proto) == ETH_P_IP)						
0000c4  e5d4100d          LDRB     r1,[r4,#0xd]
0000c8  e5d4200c          LDRB     r2,[r4,#0xc]
0000cc  e1820401          ORR      r0,r2,r1,LSL #8
0000d0  ebfffffe          BL       ntohs
0000d4  e3500b02          CMP      r0,#0x800
0000d8  1a000001          BNE      |L1.228|
;;;34     		{
;;;35     
;;;36     		 	ip_rcv_packet(skb);
0000dc  e1a00005          MOV      r0,r5
0000e0  ebfffffe          BL       ip_rcv_packet
                  |L1.228|
;;;37     
;;;38     		}
;;;39     	 	
;;;40     	}
;;;41     
;;;42     	free_skb(skb);
0000e4  e1a00005          MOV      r0,r5
0000e8  ebfffffe          BL       free_skb
;;;43     
;;;44     	return 0;
0000ec  e3a00000          MOV      r0,#0
0000f0  e8bd4070          POP      {r4-r6,lr}
;;;45     }
0000f4  e12fff1e          BX       lr
;;;46     
                          ENDP

                  NetLoadFile PROC
;;;53     
;;;54     int NetLoadFile(UINT32T addr, UINT32T give_ip, UINT32T a3, UINT32T a4)
0000f8  e92d43ff          PUSH     {r0-r9,lr}
;;;55     {
0000fc  e24ddf43          SUB      sp,sp,#0x10c
;;;56     	
;;;57     	char cInput[256];
;;;58     	UINT8T ucInNo=0;
000100  e3a04000          MOV      r4,#0
;;;59     	UINT32T	g_nKeyPress;
;;;60     	char c;
;;;61     	int ki=0;
000104  e3a07000          MOV      r7,#0
;;;62     	
;;;63     	
;;;64     	struct sk_buff *skbh;
;;;65     	char *str = "hello";
000108  e28f9f5b          ADR      r9,|L1.636|
;;;66     
;;;67     	
;;;68     	unsigned char eth_addr[ETH_ALEN];	
;;;69     	unsigned char *s;
;;;70     	int i;
;;;71     	char *p;
;;;72     	give_ip = LOCAL_IP_ADDR;
00010c  e59f0170          LDR      r0,|L1.644|
000110  e58d0110          STR      r0,[sp,#0x110]
;;;73     	s = (unsigned char *)&give_ip;
000114  e1a00000          MOV      r0,r0
;;;74     	
;;;75     	//uart_printf("Mini TFTP Server 1.0 (IP : %d.%d.%d.%d PORT: %d)\n", s[3], s[2], s[1], s[0], TFTP);		
;;;76     	//uart_printf("Type tftp -i %d.%d.%d.%d put filename at the host PC\n", s[3], s[2], s[1], s[0]);
;;;77     
;;;78     	eth_init();		
000118  ebfffffe          BL       eth_init
;;;79     	eth_get_addr(eth_addr);		
00011c  e28d0004          ADD      r0,sp,#4
000120  ebfffffe          BL       eth_get_addr
;;;80     	ip_init(give_ip);
000124  e59d0110          LDR      r0,[sp,#0x110]
000128  ebfffffe          BL       ip_init
;;;81     	udp_init();
00012c  ebfffffe          BL       udp_init
;;;82     		
;;;83     	arp_add_entry(eth_addr, give_ip);	
000130  e59d1110          LDR      r1,[sp,#0x110]
000134  e28d0004          ADD      r0,sp,#4
000138  ebfffffe          BL       arp_add_entry
;;;84     
;;;85     
;;;86     	skbh = alloc_skb(ETH_FRAME_LEN);
00013c  e59f0134          LDR      r0,|L1.632|
000140  ebfffffe          BL       alloc_skb
000144  e1a06000          MOV      r6,r0
;;;87     	
;;;88     	uart_printf(" Please input words, then press Enter:\n");
000148  e28f0f4e          ADR      r0,|L1.648|
00014c  ebfffffe          BL       uart_printf
;;;89     	uart_printf(" />");
000150  e28f0f56          ADR      r0,|L1.688|
000154  ebfffffe          BL       uart_printf
;;;90     	uart_printf(" ");
000158  e28f0f55          ADR      r0,|L1.692|
00015c  ebfffffe          BL       uart_printf
;;;91     	g_nKeyPress = 1;
000160  e3a08001          MOV      r8,#1
;;;92     	
;;;93     	for(ki=0;ki<5;ki++){
000164  e1a00000          MOV      r0,r0
000168  ea000011          B        |L1.436|
                  |L1.364|
;;;94     		net_handle();
00016c  ebfffffe          BL       net_handle
;;;95     		udp_skb_reserve(skbh);
000170  e1a00006          MOV      r0,r6
000174  ebfffffe          BL       udp_skb_reserve
;;;96     		memcpy(skbh->data,str,5);
000178  e3a02005          MOV      r2,#5
00017c  e1a01009          MOV      r1,r9
000180  e59605f0          LDR      r0,[r6,#0x5f0]
000184  ebfffffe          BL       memcpy
;;;97     		
;;;98     		uart_printf("begin sending..%s...\n",str);
000188  e1a01009          MOV      r1,r9
00018c  e28f0f49          ADR      r0,|L1.696|
000190  ebfffffe          BL       uart_printf
;;;99     		udp_send(skbh, 3232236132, UDP, 45454);
000194  e59f3134          LDR      r3,|L1.720|
000198  e3a02011          MOV      r2,#0x11
00019c  e59f1130          LDR      r1,|L1.724|
0001a0  e1a00006          MOV      r0,r6
0001a4  ebfffffe          BL       udp_send
;;;100    		uart_printf("finish sending..\n");
0001a8  e28f0f4a          ADR      r0,|L1.728|
0001ac  ebfffffe          BL       uart_printf
0001b0  e2877001          ADD      r7,r7,#1              ;93
                  |L1.436|
0001b4  e3570005          CMP      r7,#5                 ;93
0001b8  baffffeb          BLT      |L1.364|
;;;101    	}
;;;102    
;;;103    	
;;;104    	while (1) {		
0001bc  ea00002c          B        |L1.628|
                  |L1.448|
;;;105    
;;;106    		while(g_nKeyPress==1)			// only for board test to exit
0001c0  ea000010          B        |L1.520|
                  |L1.452|
;;;107    	{
;;;108    		c=uart_getch();
0001c4  ebfffffe          BL       uart_getch
0001c8  e1a05000          MOV      r5,r0
;;;109    		
;;;110    		uart_printf("%c",c);
0001cc  e1a01005          MOV      r1,r5
0001d0  e28f0f45          ADR      r0,|L1.748|
0001d4  ebfffffe          BL       uart_printf
;;;111    		if(c!='\r')
0001d8  e355000d          CMP      r5,#0xd
0001dc  0a000005          BEQ      |L1.504|
;;;112    			cInput[ucInNo++]=c;
0001e0  e1a00004          MOV      r0,r4
0001e4  e2841001          ADD      r1,r4,#1
0001e8  e20140ff          AND      r4,r1,#0xff
0001ec  e28d100c          ADD      r1,sp,#0xc
0001f0  e7c15000          STRB     r5,[r1,r0]
0001f4  ea000003          B        |L1.520|
                  |L1.504|
;;;113    		else
;;;114    		{
;;;115    			cInput[ucInNo]='\0';
0001f8  e3a00000          MOV      r0,#0
0001fc  e28d100c          ADD      r1,sp,#0xc
000200  e7c10004          STRB     r0,[r1,r4]
;;;116    			break;
000204  ea000001          B        |L1.528|
                  |L1.520|
000208  e3580001          CMP      r8,#1                 ;106
00020c  0affffec          BEQ      |L1.452|
                  |L1.528|
000210  e1a00000          MOV      r0,r0
;;;117    		}
;;;118    	}
;;;119    	delay(1000);	
000214  e3a00ffa          MOV      r0,#0x3e8
000218  ebfffffe          BL       delay
;;;120    	net_handle();
00021c  ebfffffe          BL       net_handle
;;;121    	udp_skb_reserve(skbh);
000220  e1a00006          MOV      r0,r6
000224  ebfffffe          BL       udp_skb_reserve
;;;122    	memcpy(skbh->data,cInput,ucInNo+1);
000228  e2842001          ADD      r2,r4,#1
00022c  e28d100c          ADD      r1,sp,#0xc
000230  e59605f0          LDR      r0,[r6,#0x5f0]
000234  ebfffffe          BL       memcpy
;;;123    		
;;;124    	uart_printf("begin sending..%s...\n",cInput);
000238  e28d100c          ADD      r1,sp,#0xc
00023c  e28f0074          ADR      r0,|L1.696|
000240  ebfffffe          BL       uart_printf
;;;125    	udp_send(skbh, 3232236132, UDP, 45454);
000244  e59f3084          LDR      r3,|L1.720|
000248  e3a02011          MOV      r2,#0x11
00024c  e59f1080          LDR      r1,|L1.724|
000250  e1a00006          MOV      r0,r6
000254  ebfffffe          BL       udp_send
;;;126    	uart_printf("finish sending..\n");
000258  e28f0078          ADR      r0,|L1.728|
00025c  ebfffffe          BL       uart_printf
;;;127    	memcpy(cInput,"",ucInNo+1);
000260  e2842001          ADD      r2,r4,#1
000264  e28f1084          ADR      r1,|L1.752|
000268  e28d000c          ADD      r0,sp,#0xc
00026c  ebfffffe          BL       memcpy
;;;128    			ucInNo=0;
000270  e3a04000          MOV      r4,#0
                  |L1.628|
000274  eaffffd1          B        |L1.448|
;;;129    	}
;;;130    	
;;;131    	
;;;132    		
;;;133    	/*
;;;134    	while (1) {		
;;;135    		net_handle();
;;;136    		udp_skb_reserve(skbh);
;;;137    		memcpy(skbh->data,str,5);
;;;138    		
;;;139    		uart_printf("begin sending..%s...\n",str);
;;;140    		//udp_send(skbh, 3232236132, UDP, 45454);
;;;141    		uart_printf("finish sending..\n");
;;;142    		
;;;143    		delay(5000);
;;;144    	}
;;;145    	*/
;;;146      
;;;147    	
;;;148    
;;;149    	return 0;
;;;150    }
;;;151    
                          ENDP

                  |L1.632|
                          DCD      0x000005ea
                  |L1.636|
00027c  68656c6c          DCB      "hello",0
000280  6f00    
000282  00                DCB      0
000283  00                DCB      0
                  |L1.644|
                          DCD      0xc0a8026f
                  |L1.648|
000288  20506c65          DCB      " Please input words, then press Enter:\n",0
00028c  61736520
000290  696e7075
000294  7420776f
000298  7264732c
00029c  20746865
0002a0  6e207072
0002a4  65737320
0002a8  456e7465
0002ac  723a0a00
                  |L1.688|
0002b0  202f3e00          DCB      " />",0
                  |L1.692|
0002b4  2000              DCB      " ",0
0002b6  00                DCB      0
0002b7  00                DCB      0
                  |L1.696|
0002b8  62656769          DCB      "begin sending..%s...\n",0
0002bc  6e207365
0002c0  6e64696e
0002c4  672e2e25
0002c8  732e2e2e
0002cc  0a00    
0002ce  00                DCB      0
0002cf  00                DCB      0
                  |L1.720|
                          DCD      0x0000b18e
                  |L1.724|
                          DCD      0xc0a80264
                  |L1.728|
0002d8  66696e69          DCB      "finish sending..\n",0
0002dc  73682073
0002e0  656e6469
0002e4  6e672e2e
0002e8  0a00    
0002ea  00                DCB      0
0002eb  00                DCB      0
                  |L1.748|
0002ec  256300            DCB      "%c",0
0002ef  00                DCB      0
                  |L1.752|
0002f0  00                DCB      0
0002f1  00                DCB      0
0002f2  00                DCB      0
0002f3  00                DCB      0

                          AREA ||.data||, DATA, ALIGN=0

                  TftpLoadEnd
000000  00                DCB      0x00
                  TftpPutBegin
000001  00                DCB      0x00
                  TftpPutMark
000002  00                DCB      0x00

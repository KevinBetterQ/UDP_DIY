; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\SDRAM\udp.o --asm_dir=.\SDRAM\ --list_dir=.\SDRAM\ --depend=.\SDRAM\udp.d --cpu=ARM920T --apcs=interwork -O0 -I..\Common\Inc -I.\INC -I.\INC\tftp -IC:\Keil\ARM\RV31\INC -IC:\Keil\ARM\CMSIS\Include -IC:\Keil\ARM\Inc\Samsung --omf_browse=.\SDRAM\udp.crf Source\tftp\udp.c]
                          ARM

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  udp_init PROC
;;;10     
;;;11     int udp_init(void)
000000  e3a00000          MOV      r0,#0
;;;12     {
;;;13     	return 0;
;;;14     }
000004  e12fff1e          BX       lr
;;;15     
                          ENDP

                  udp_rcv_packet PROC
;;;16     int udp_rcv_packet(struct sk_buff *skb)
000008  e92d4070          PUSH     {r4-r6,lr}
;;;17     {
00000c  e1a04000          MOV      r4,r0
;;;18     	struct udphdr *udp_hdr = (struct udphdr *)(skb->data);
000010  e59455f0          LDR      r5,[r4,#0x5f0]
;;;19     
;;;20     	skb->len = ntohs(udp_hdr->len);
000014  e5d51005          LDRB     r1,[r5,#5]
000018  e5d52004          LDRB     r2,[r5,#4]
00001c  e1820401          ORR      r0,r2,r1,LSL #8
000020  ebfffffe          BL       ntohs
000024  e58405f4          STR      r0,[r4,#0x5f4]
;;;21     	skb_pull(skb, sizeof(struct udphdr));
000028  e3a01008          MOV      r1,#8
00002c  e1a00004          MOV      r0,r4
000030  ebfffffe          BL       skb_pull
;;;22     
;;;23     	if (ntohs(udp_hdr->dest) == TFTP)
000034  e5d51003          LDRB     r1,[r5,#3]
000038  e5d52002          LDRB     r2,[r5,#2]
00003c  e1820401          ORR      r0,r2,r1,LSL #8
000040  ebfffffe          BL       ntohs
000044  e3500045          CMP      r0,#0x45
000048  1a000001          BNE      |L1.84|
;;;24     	{
;;;25     		tftp_rcv_packet(skb);
00004c  e1a00004          MOV      r0,r4
000050  ebfffffe          BL       tftp_rcv_packet
                  |L1.84|
;;;26     	}
;;;27     
;;;28     	return 0;
000054  e3a00000          MOV      r0,#0
000058  e8bd4070          POP      {r4-r6,lr}
;;;29     }
00005c  e12fff1e          BX       lr
;;;30     
                          ENDP

                  udp_send PROC
;;;31     int udp_send(struct sk_buff *skb, unsigned long ip,
000060  e92d41f0          PUSH     {r4-r8,lr}
;;;32     	unsigned short source, unsigned short dest)
;;;33     {
000064  e1a07000          MOV      r7,r0
000068  e1a08001          MOV      r8,r1
00006c  e1a05002          MOV      r5,r2
000070  e1a06003          MOV      r6,r3
;;;34     	struct udphdr *udp_hdr;
;;;35     
;;;36     	udp_hdr = (struct udphdr *)skb_push(skb, sizeof(struct udphdr));
000074  e3a01008          MOV      r1,#8
000078  e1a00007          MOV      r0,r7
00007c  ebfffffe          BL       skb_push
000080  e1a04000          MOV      r4,r0
;;;37     	udp_hdr->source = htons(source);
000084  e1a00005          MOV      r0,r5
000088  ebfffffe          BL       htons
00008c  e5c40000          STRB     r0,[r4,#0]
000090  e1a00420          LSR      r0,r0,#8
000094  e5c40001          STRB     r0,[r4,#1]
;;;38     	udp_hdr->dest = htons(dest);
000098  e1a00006          MOV      r0,r6
00009c  ebfffffe          BL       htons
0000a0  e5c40002          STRB     r0,[r4,#2]
0000a4  e1a00420          LSR      r0,r0,#8
0000a8  e5c40003          STRB     r0,[r4,#3]
;;;39     	udp_hdr->len = htons(30);
0000ac  e3a0001e          MOV      r0,#0x1e
0000b0  ebfffffe          BL       htons
0000b4  e5c40004          STRB     r0,[r4,#4]
0000b8  e1a00420          LSR      r0,r0,#8
0000bc  e5c40005          STRB     r0,[r4,#5]
;;;40     	udp_hdr->check = 0;
0000c0  e3a00000          MOV      r0,#0
0000c4  e5c40006          STRB     r0,[r4,#6]
0000c8  e5c40007          STRB     r0,[r4,#7]
;;;41     
;;;42     	ip_send(skb, ip, UDP);
0000cc  e3a02011          MOV      r2,#0x11
0000d0  e1a01008          MOV      r1,r8
0000d4  e1a00007          MOV      r0,r7
0000d8  ebfffffe          BL       ip_send
;;;43     
;;;44     	return 0;
0000dc  e3a00000          MOV      r0,#0
0000e0  e8bd41f0          POP      {r4-r8,lr}
;;;45     }
0000e4  e12fff1e          BX       lr
;;;46     
                          ENDP

                  udp_skb_reserve PROC
;;;47     void udp_skb_reserve(struct sk_buff *skb)
0000e8  e92d4010          PUSH     {r4,lr}
;;;48     {
0000ec  e1a04000          MOV      r4,r0
;;;49     	ip_skb_reserve(skb);
0000f0  e1a00004          MOV      r0,r4
0000f4  ebfffffe          BL       ip_skb_reserve
;;;50     	skb_reserve(skb, sizeof(struct udphdr));
0000f8  e3a01008          MOV      r1,#8
0000fc  e1a00004          MOV      r0,r4
000100  ebfffffe          BL       skb_reserve
;;;51     }
000104  e8bd4010          POP      {r4,lr}
000108  e12fff1e          BX       lr
;;;52     
                          ENDP

                  udp_get_source_port PROC
;;;53     unsigned short udp_get_source_port(struct sk_buff *skb)
00010c  e92d4070          PUSH     {r4-r6,lr}
;;;54     {
000110  e1a04000          MOV      r4,r0
;;;55     	struct udphdr *udp_hdr;
;;;56     	
;;;57     	udp_hdr = (struct udphdr *)(skb->buf + ETH_HLEN + sizeof(struct iphdr));
000114  e2845024          ADD      r5,r4,#0x24
;;;58     	return ntohs(udp_hdr->source);
000118  e5d51001          LDRB     r1,[r5,#1]
00011c  e5d52000          LDRB     r2,[r5,#0]
000120  e1820401          ORR      r0,r2,r1,LSL #8
000124  ebfffffe          BL       ntohs
000128  e8bd4070          POP      {r4-r6,lr}
;;;59     }
00012c  e12fff1e          BX       lr
;;;60     
                          ENDP


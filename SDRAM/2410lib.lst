L 1 "..\common\src\2410lib.c"
N/*********************************************************************************************
N* File name	: 2410lib.c
N* Author	: embest
N* Descript	: s3c2410 function library 
N* History
N*********************************************************************************************/
N
N/*------------------------------------------------------------------------------------------*/
N/*	 								include files						 				    */
N/*------------------------------------------------------------------------------------------*/
N#include <stdarg.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\stdarg.h" 1
N/* stdarg.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.8 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright (C) ARM Ltd., 1991-1999. All rights reserved */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N
N#ifndef __stdarg_h
N#define __stdarg_h
N#define __ARMCLIB_VERSION 5030024
N
N  #ifndef __STDARG_DECLS
N  #define __STDARG_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/*
N * stdarg.h declares a type and defines macros for advancing through a
N * list of arguments whose number and types are not known to the called
N * function when it is translated. A function may be called with a variable
N * number of arguments of differing types. Its parameter list contains one or
N * more parameters. The rightmost parameter plays a special role in the access
N * mechanism, and will be called parmN in this description.
N */
N
N/* N.B. <stdio.h> is required to declare vfprintf() without defining      */
N/* va_list.  Clearly the type __va_list there must keep in step.          */
N  typedef struct __va_list { void *__ap; } va_list;
N
N   /*
N    * an array type suitable for holding information needed by the macro va_arg
N    * and the function va_end. The called function shall declare a variable
N    * (referred to as ap) having type va_list. The variable ap may be passed as
N    * an argument to another function.
N    * Note: va_list is an array type so that when an object of that type
N    * is passed as an argument it gets passed by reference.
N    */
N  #define va_start(ap, parmN) __va_start(ap, parmN)
N
N   /*
N    * The va_start macro shall be executed before any access to the unnamed
N    * arguments. The parameter ap points to an object that has type va_list.
N    * The va_start macro initialises ap for subsequent use by va_arg and
N    * va_end. The parameter parmN is the identifier of the rightmost parameter
N    * in the variable parameter list in the function definition (the one just
N    * before the '...'). If the parameter parmN is declared with the register
N    * storage class an error is given.
N    * If parmN is a narrow type (char, short, float) an error is given in
N    * strict ANSI mode, or a warning otherwise.
N    * Returns: no value.
N    */
N  #define va_arg(ap, type) __va_arg(ap, type)
N
N   /*
N    * The va_arg macro expands to an expression that has the type and value of
N    * the next argument in the call. The parameter ap shall be the same as the
N    * va_list ap initialised by va_start. Each invocation of va_arg modifies
N    * ap so that successive arguments are returned in turn. The parameter
N    * 'type' is a type name such that the type of a pointer to an object that
N    * has the specified type can be obtained simply by postfixing a * to
N    * 'type'. If type is a narrow type, an error is given in strict ANSI
N    * mode, or a warning otherwise. If the type is an array or function type,
N    * an error is given.
N    * In non-strict ANSI mode, 'type' is allowed to be any expression.
N    * Returns: The first invocation of the va_arg macro after that of the
N    *          va_start macro returns the value of the argument after that
N    *          specified by parmN. Successive invocations return the values of
N    *          the remaining arguments in succession.
N    *          The result is cast to 'type', even if 'type' is narrow.
N    */
N
N#define __va_copy(dest, src) ((void)((dest) = (src)))
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N   /* va_copy is in C99 and non-strict C90 and non-strict C++
N    * __va_copy is always present.
N    */
N  #define va_copy(dest, src) ((void)((dest) = (src)))
N
N   /* The va_copy macro makes the va_list dest be a copy of
N    * the va_list src, as if the va_start macro had been applied
N    * to it followed by the same sequence of uses of the va_arg
N    * macro as had previously been used to reach the present state
N    * of src.
N    */
N#endif
N
N#define va_end(ap) __va_end(ap)
N   /*
N    * The va_end macro facilitates a normal return from the function whose
N    * variable argument list was referenced by the expansion of va_start that
N    * initialised the va_list ap. If the va_end macro is not invoked before
N    * the return, the behaviour is undefined.
N    * Returns: no value.
N    */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N
N    #ifdef __GNUC__
S     /* be cooperative with glibc */
S     typedef __CLIBNS va_list __gnuc_va_list;
S     #define __GNUC_VA_LIST
S     #undef __need___va_list
N    #endif
N
N  #endif /* __STDARG_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDARG_NO_EXPORTS
S      using ::std::va_list;
S    #endif
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stdarg.h */
N
L 12 "..\common\src\2410lib.c" 2
N#include <string.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5030024
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 13 "..\common\src\2410lib.c" 2
N#include <stdio.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5030024
N
N
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;   /* see <stddef.h> */
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined)
X#if 0L || !0L || !0L
N/* always defined in C++ and non-strict C for consistency of debug info */
N  typedef struct __va_list __va_list;
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#if !0L || (1L && 199901L <= 199409L)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 14 "..\common\src\2410lib.c" 2
N#include <ctype.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\ctype.h" 1
N/* ctype.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.3 */
N/* Copyright (C) Codemist Ltd. 1988-1993.                       */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.        */
N/* version 0.03 */
N
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N
N/*
N * ctype.h declares several functions useful for testing and mapping
N * characters. In all cases the argument is an int, the value of which shall
N * be representable as an unsigned char or shall equal the value of the
N * macro EOF. If the argument has any other value, the behaviour is undefined.
N */
N
N#ifndef __ctype_h
N#define __ctype_h
N#define __ARMCLIB_VERSION 5030024
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __pure
N
N#ifdef __cplusplus
S#define _ARMABI_INLINE_DEF inline
S#elif defined(__GNUC__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#elif 0L || (1L && 199901L <= 199409L)
S#define _ARMABI_INLINE_DEF static inline
N#else
N#define _ARMABI_INLINE_DEF __inline
N#endif
N
N  #ifndef __CTYPE_DECLS
N  #define __CTYPE_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/* AEABI portable ctype flag bits */
N#define _ABI_A    1       /* alphabetic        */
N#define _ABI_X    2       /* A-F, a-f and 0-9  */
N#define _ABI_P    4       /* punctuation       */
N#define _ABI_B    8       /* blank             */
N#define _ABI_S   16       /* white space       */
N#define _ABI_L   32       /* lower case letter */
N#define _ABI_U   64       /* upper case letter */
N#define _ABI_C  128       /* control chars     */
N
N/* ARM internal ctype flag bits */
N/* N.B. - keep in step with <ctype.c> */
N
N/*
N * __ARM_CT_A (alphabetic) is required because characters in some locales
N * (e.g. Japanese) can be alphabetic but neither uppercase nor
N * lowercase. Unfortunately there wasn't a bit free for this, so
N * instead we've defined __ARM_CT_A as __ARM_CT_N+__ARM_CT_X (on the grounds that this
N * was a previously unused combination). Hence some of the ctype
N * predicates below are slightly less than obvious in
N * implementation.
N */
N#define __ARM_CT_S 1            /* whitespace           */
N#define __ARM_CT_P 2            /* punctuation          */
N#define __ARM_CT_B 4            /* blank                */
N#define __ARM_CT_L 8            /* lower case letter    */
N#define __ARM_CT_U 16           /* upper case letter    */
N#define __ARM_CT_N 32           /* (decimal) digit      */
N#define __ARM_CT_C 64           /* control chars        */
N#define __ARM_CT_X 128          /* A-F and a-f          */
N#define __ARM_CT_A (__ARM_CT_N+__ARM_CT_X)    /* alphabetic           */
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S
Sextern int (isalnum)(int /*c*/);
Sextern int (isalpha)(int /*c*/);
Sextern int (isblank)(int /*c*/);
Sextern int (iscntrl)(int /*c*/);
Sextern int (isdigit)(int /*c*/);
Sextern int (isgraph)(int /*c*/);
Sextern int (islower)(int /*c*/);
Sextern int (isprint)(int /*c*/);
Sextern int (ispunct)(int /*c*/);
Sextern int (isspace)(int /*c*/);
Sextern int (isupper)(int /*c*/);
Sextern int (isxdigit)(int /*c*/);
S
S/* Mandatory character attribute arrays indexed from 0 to 256 */
Sextern unsigned char const __aeabi_ctype_table_C[257];  /* "C" locale */
Sextern unsigned char const __aeabi_ctype_table_[257];   /* default locale */
S         /* The default locale might be the C locale */
S/* Optional character attribute arrays indexed from 0 to 256.        */
S/* These do not have to be provided by every execution environment   */
S/* but, if provided, shall be provided with these names and meaning. */
Sextern unsigned char const __aeabi_ctype_table_ISO8859_1[257];
Sextern unsigned char const __aeabi_ctype_table_SJIS[257];
Sextern unsigned char const __aeabi_ctype_table_BIG5[257];
Sextern unsigned char const __aeabi_ctype_table_UTF8[257];
S#ifdef _AEABI_LC_CTYPE
S# define _AEABI_CTYPE_TABLE(_X) __aeabi_ctype_table_ ## _X
S# define _AEABI_CTYPE(_X) _AEABI_CTYPE_TABLE(_X)
S# define __aeabi_ctype_table _AEABI_CTYPE(_AEABI_LC_CTYPE)
S#else
S# define __aeabi_ctype_table __aeabi_ctype_table_
S#endif
S
S#define isspace(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_S)
S#define isalpha(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_A)
S#define isalnum(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 30) /* test for _ABI_A and _ABI_X */
S#define isprint(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 28) /* test for _ABI_A, _ABI_X, _ABI_P and _ABI_B */
S#define isupper(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_U)
S#define islower(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_L)
S#define isxdigit(x) ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_X)
S#define isgraph(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 29) /* test for _ABI_A, _ABI_X and _ABI_P */
S#define iscntrl(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_C)
S#define ispunct(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_P)
S#define isdigit(c)  (((unsigned)(c) - '0') < 10)
S
N#else /* __AEABI_PORTABILITY_LEVEL */
N
Nextern _ARMABI_PURE unsigned char **__rt_ctype_table(void);
Xextern __declspec(__nothrow) __pure unsigned char **__rt_ctype_table(void);
N
N#define __arm_ctype (*__CLIBNS __rt_ctype_table())
N
N#ifdef __cplusplus
S    inline int isalnum(int __c) { return (__arm_ctype[__c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_N)); }
N#else
N    #define isalnum(c) (__arm_ctype[c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_N))
N    extern int (isalnum)(int /*c*/);
N#endif
N    /* non-0 iff c is alphabetic or numeric */
N
N#ifdef __cplusplus
S    inline int isalpha(int __c) { return (__arm_ctype[__c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_X)); }
N#else
N    #define isalpha(c) (__arm_ctype[c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_X))
N    extern int (isalpha)(int /*c*/);
N#endif
N    /* non-0 iff c is alphabetic */
N
N#ifdef __cplusplus
S    inline int iscntrl(int __c) { return (__arm_ctype[__c] & __ARM_CT_C); }
N#else
N    #define iscntrl(c) (__arm_ctype[c] & __ARM_CT_C)
N    extern int (iscntrl)(int /*c*/);
N#endif
N    /* non-0 iff c is a control character - in the "C" locale */
N    /*       this means (c < ' ') || (c > '~')                */
N
N/* isdigit must test for the presence of _only_ __ARM_CT_N, not just __ARM_CT_N at all. */
N#ifdef __cplusplus
S    inline int isdigit(int __c) { return (__arm_ctype[__c] == __ARM_CT_N); }
N#else
N    #define isdigit(c) (__arm_ctype[c] == __ARM_CT_N)
N    extern int (isdigit)(int /*c*/);
N#endif
N    /* non-0 iff c is a decimal digit */
N
N    extern int (isblank)(int /*c*/);
N    /* non-0 iff c is ' ', '\t' or some other locale-specific, */
N    /* word-separating character (there are no others in "C"   */
N    /* locale) */
N
N#ifdef __cplusplus
S    inline int isgraph(int __c) {return(__arm_ctype[__c] & (__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_X+__ARM_CT_P));}
N#else
N    #define isgraph(c) (__arm_ctype[c]&(__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_X+__ARM_CT_P))
N    extern int (isgraph)(int /*c*/);
N#endif
N    /* non-0 iff c is any printing character other than ' ' */
N
N#ifdef __cplusplus
S    inline int islower(int __c) { return (__arm_ctype[__c] & __ARM_CT_L); }
N#else
N    #define islower(c) (__arm_ctype[c] & __ARM_CT_L)
N    extern int (islower)(int /*c*/);
N#endif
N    /* non-0 iff c is a lower-case letter */
N
N#ifdef __cplusplus
S    inline int isprint(int __c) { return (__arm_ctype[__c] & (__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_P+__ARM_CT_B)); }
N#else
N    #define isprint(c) (__arm_ctype[c] & (__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_P+__ARM_CT_B))
N    extern int (isprint)(int /*c*/);
N#endif
N    /* non-0 iff c is a printing character - in the "C" locale */
N    /*       this means 0x20 (space) -> 0x7E (tilde)           */
N
N#ifdef __cplusplus
S    inline int ispunct(int __c) { return (__arm_ctype[__c] & __ARM_CT_P); }
N#else
N    #define ispunct(c) (__arm_ctype[c] & __ARM_CT_P)
N    extern int (ispunct)(int /*c*/);
N#endif
N    /* non-0 iff c is a non-space, non-alpha-numeric, printing character */
N
N#ifdef __cplusplus
S    inline int isspace(int __c) { return (__arm_ctype[__c] & __ARM_CT_S); }
N#else
N    #define isspace(c) (__arm_ctype[c] & __ARM_CT_S)
N    extern int (isspace)(int /*c*/);
N#endif
N    /* non-0 iff c is a white-space char: ' ', '\f', '\n', '\r', '\t', '\v'. */
N
N#ifdef __cplusplus
S    inline int isupper(int __c) { return (__arm_ctype[__c] & __ARM_CT_U); }
N#else
N    #define isupper(c) (__arm_ctype[c] & __ARM_CT_U)
N    extern int (isupper)(int /*c*/);
N#endif
N    /* non-0 iff c is an upper-case letter */
N
N/* isxdigit must test for the presence of __ARM_CT_N or __ARM_CT_X but not both. */
N/* This helper function avoids needing to evaluate c twice. */
N
N_ARMABI_INLINE_DEF int __isxdigit_helper(int __t) { return (__t ^ (__t << 2)); }
X__inline int __isxdigit_helper(int __t) { return (__t ^ (__t << 2)); }
N#ifdef __cplusplus
S    inline int isxdigit(int __c){return __isxdigit_helper(__arm_ctype[__c]) & __ARM_CT_X;}
N#else
N    #define isxdigit(c) (__isxdigit_helper(__arm_ctype[c]) & __ARM_CT_X)
N    extern int (isxdigit)(int /*c*/);
N#endif
N    /* non-0 iff c is a digit, in 'a'..'f', or in 'A'..'F' */
N
N#endif /* __AEABI_PORTABILITY_LEVEL */
N
Nextern int tolower(int /*c*/);
N    /* if c is an upper-case letter then return the corresponding */
N    /* lower-case letter, otherwise return c.                     */
N
Nextern int toupper(int /*c*/);
N    /* if c is an lower-case letter then return the corresponding */
N    /* upper-case letter, otherwise return c.                     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __CTYPE_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __CTYPE_NO_EXPORTS
S      using ::std::isalnum;
S      using ::std::isalpha;
S      using ::std::iscntrl;
S      using ::std::isdigit;
S      using ::std::isblank;
S      using ::std::isgraph;
S      using ::std::islower;
S      using ::std::isprint;
S      using ::std::ispunct;
S      using ::std::isspace;
S      using ::std::isupper;
S      using ::std::isxdigit;
S      using ::std::tolower;
S      using ::std::toupper;
S    #endif /* __CTYPE_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of ctype.h */
N
L 15 "..\common\src\2410lib.c" 2
N#include <stdlib.h>
L 1 "C:\Keil\ARM\ARMCC\bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.            */
N/*
N * RCS $Revision: 178085 $
N * Checkin $Date: 2012-12-11 14:54:17 +0000 (Tue, 11 Dec 2012) $
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5030024
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __pure
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X    #if 0L || (1L && 199901L <= 199409L)
S      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  typedef unsigned int size_t;
N#elif !defined(__size_t)
S  #define __size_t 1
S  typedef unsigned int size_t;   /* see <stddef.h> */
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32)
X   #if 0L
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Ntypedef struct lldiv_t { __int64 quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI __int64 atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) __int64 atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __int64 strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) __int64 strtoll(const char * __restrict  ,
N                               char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __int64 strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned __int64 strtoull(const char * __restrict  ,
N                                         char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && !defined(__GNUC__)
X#if 0L && !0L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __pure int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __pure div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __pure long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __pure ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI_PURE __int64 llabs(__int64 /*j*/);
Xextern __declspec(__nothrow) __pure __int64 llabs(__int64  );
N   /*
N    * computes the absolute value of a __int64 integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __int64 abs(__int64 x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__int64 /*numer*/, __int64 /*denom*/);
Xextern __declspec(__nothrow) __pure lldiv_t lldiv(__int64  , __int64  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__int64 __numer, __int64 __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __pure __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __pure __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __pure __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N/* end of stdlib.h */
N
L 16 "..\common\src\2410lib.c" 2
N#include "2410lib.h"
L 1 "..\Common\Inc\2410lib.h" 1
N/*********************************************************************************************
N* File name	: 2410lib.h
N* Author	: embest
N* Descript	: S3C2410 Define Address Register 
N* History
N*********************************************************************************************/
N
N/*------------------------------------------------------------------------------------------*/
N/*	 								include files						 				    */
N/*------------------------------------------------------------------------------------------*/
N#include "def.h"
L 1 "..\Common\Inc\def.h" 1
N/*********************************************************************************************
N* File name	: 2410lib.h
N* Author	: embest
N* Descript	: S3C2410 Example 
N* History
N*********************************************************************************************/
N#ifndef __DEF_H__
N#define __DEF_H__
N
N#define UINT32T unsigned int
N#define INT32T	int
N#define UINT16T unsigned short
N#define INT16T	short int
N#define UINT8T  unsigned char
N#define	INT8T  char
N
N#define TRUE 	1
N#define FALSE 	0
N#define OK		1
N#define FAIL	0
N#define FileEnd	1
N#define	NotEnd	0
N
N#define False 0
N#define True !False
N
N// Sets the result on bPort 
N#define BIT_SET(bPort,bBitMask)        (bPort |= bBitMask)
N#define BIT_CLR(bPort,bBitMask)        (bPort &= ~bBitMask)
N
N// Returns the result
N#define GET_BIT_SET(bPort,bBitMask)    (bPort | bBitMask)
N#define GET_BIT_CLR(bPort,bBitMask)    (bPort & ~bBitMask)
N
N// Returns 0 if the condition is False & a non-zero value if it is True
N#define TEST_BIT_SET(bPort,bBitMask)   (bPort & bBitMask)
N#define TEST_BIT_CLR(bPort,bBitMask)   ((~bPort) & bBitMask)
N
N#endif /*__DEF_H__*/
N
L 12 "..\Common\Inc\2410lib.h" 2
N#include "memcfg.h"
L 1 "..\Common\Inc\memcfg.h" 1
N//************************************************ 
N// NAME    : memcfg.inc
N// DESC	  : Memory bank configuration file
N// Revision: 02.28.2002 ver 0.0
N//************************************************
N
N//Memory Area
N//GCS6 16bit(16MB) SDRAM(0x0c000000-0x0cffffff)
N//GCS7 16bit(16MB) SDRAM(0x0d000000-0x0dffffff)
N//          or
N//GCS6 32bit(32MB) SDRAM(0x0c000000-0x0dffffff)
N
N#ifndef __MEMCFG_H
N#define __MEMCFG_H
N 
N// BUSWIDTH : 16,32
N#define BUSWIDTH    (32)
N
N//64MB
N// 0x30000000 ~ 0x30ffffff : Download Area (16MB) Cacheable
N// 0x31000000 ~ 0x33feffff : Non-Cacheable Area
N// 0x33ff0000 ~ 0x33ff47ff : Heap & RW Area
N// 0x33ff4800 ~ 0x33ff7fff : FIQ ~ User Stack Area
N// 0x33ff8000 ~ 0x33fffeff : Not Used Area
N// 0x33ffff00 ~ 0x33ffffff : Exception & ISR Vector Table
N
N#define _RAM_STARTADDRESS       0x30000000
N#define _NONCACHE_STARTADDRESS	0x31000000
N#define _ISR_STARTADDRESS       0x33ffff00     
N#define _MMUTT_STARTADDRESS     0x33ff8000
N#define _STACK_BASEADDRESS      0x33ff8000
N#define HEAPEND                 0x33ff0000
N
N//BWSCON
N#define DW8			(0x0)
N#define DW16			(0x1)
N#define DW32			(0x2)
N#define WAIT			(0x1<<2)
N#define UBLB			(0x1<<3)
N
N//BUSWIDTH=32
N
N#define B1_BWSCON	 (DW32)
N#define B2_BWSCON	 (DW16)
N#define B3_BWSCON	 (DW16)
N#define B4_BWSCON	 (DW16)
N#define B5_BWSCON	 (DW16)
N#define B6_BWSCON	 (DW32)
N#define B7_BWSCON	 (DW32)
N    
N
N//BANK0CON 
N#define B0_Tacs			0x0	//0clk
N#define B0_Tcos			0x0	//0clk
N#define B0_Tacc			0x7	//14clk
N#define B0_Tcoh			0x0	//0clk
N#define B0_Tah			0x0	//0clk
N#define B0_Tacp			0x0	
N#define B0_PMC			0x0	//normal
N
N//BANK1CON
N#define B1_Tacs			0x0	//0clk
N#define B1_Tcos			0x0	//0clk
N#define B1_Tacc			0x7	//14clk
N#define B1_Tcoh			0x0	//0clk
N#define B1_Tah			0x0	//0clk
N#define B1_Tacp			0x0	
N#define B1_PMC			0x0	//normal
N
N//Bank 2 parameter
N#define B2_Tacs			0x0	//0clk
N#define B2_Tcos			0x0	//0clk
N#define B2_Tacc			0x7	//14clk
N#define B2_Tcoh			0x0	//0clk
N#define B2_Tah			0x0	//0clk
N#define B2_Tacp			0x0	
N#define B2_PMC			0x0	//normal
N
N//Bank 3 parameter
N#define B3_Tacs			0x0	//0clk
N#define B3_Tcos			0x0	//0clk
N#define B3_Tacc			0x7	//14clk
N#define B3_Tcoh			0x0	//0clk
N#define B3_Tah			0x0	//0clk
N#define B3_Tacp			0x0	
N#define B3_PMC			0x0	//normal
N
N//Bank 4 parameter
N#define B4_Tacs			0x0	//0clk
N#define B4_Tcos			0x0	//0clk
N#define B4_Tacc			0x7	//14clk
N#define B4_Tcoh			0x0	//0clk
N#define B4_Tah			0x0	//0clk
N#define B4_Tacp			0x0	
N#define B4_PMC			0x0	//normal
N
N//Bank 5 parameter
N#define B5_Tacs			0x0	//0clk
N#define B5_Tcos			0x0	//0clk
N#define B5_Tacc			0x7	//14clk
N#define B5_Tcoh			0x0	//0clk
N#define B5_Tah			0x0	//0clk
N#define B5_Tacp			0x0	
N#define B5_PMC			0x0	//normal
N
N//Bank 6 parameter
N#define B6_MT			0x3	//SDRAM
N//B6_Trcd			0x0	//2clk
N#define B6_Trcd			0x1	//3clk
N#define B6_SCAN			0x1	//9bit
N
N//Bank 7 parameter
N#define B7_MT			0x3	//SDRAM
N//B7_Trcd			0x0	//2clk
N#define B7_Trcd			0x1	//3clk
N#define B7_SCAN			0x1	//9bit
N
N//REFRESH parameter
N#define REFEN	  	    0x1	//Refresh enable
N#define TREFMD	  	    0x0	//CBR(CAS before RAS)/Auto refresh
N#define Trp	  	        0x0	//2clk
N#define Trc	  	        0x3	//7clk
N		
N#define Tchr			0x2	//3clk
N#define REFCNT			1113	//period=15.6us, HCLK=60Mhz, (2048+1-15.6*60)
N
N
N#endif
N
L 13 "..\Common\Inc\2410lib.h" 2
N#include "option.h"
L 1 "..\Common\Inc\option.h" 1
N/*********************************************************************************************
N* File name	: option.h
N* Author	: embest
N* Descript	: Define S3C2410 CPU Option contents 
N* History
N*********************************************************************************************/
N
N#ifndef __OPTION_H__
N#define __OPTION_H__
N
N#define FCLK 202800000
N#define HCLK (202800000/2)
N#define PCLK (202800000/4)
N#define UCLK PCLK
N
N#ifdef CLK111_50M
S#define FCLK 50000000
S#define HCLK 50000000
S#define PCLK 50000000
S#define UCLK 50000000
N#endif
N
N#ifdef CLK124_135M
S#define FCLK 135428571
S#define HCLK (135428571/2)
S#define PCLK (135428571/4)
N#endif
N
N#ifdef CLK124_200M
S#define FCLK 200000000
S#define HCLK (200000000/2)
S#define PCLK (200000000/4)
N#endif
N
N#ifdef CLK124_220M
S#define FCLK 220000000
S#define HCLK (220000000/2)
S#define PCLK (220000000/4)
N#endif
N
N#ifdef CLK124_226M
S#define FCLK 226000000
S#define HCLK (226000000/2)
S#define PCLK (226000000/4)
N#endif
N
N#ifdef CLK124_237M
S#define FCLK 237000000
S#define HCLK (237000000/2)
S#define PCLK (237000000/4)
S#define UCLK 50000000
N#endif
N
N#define FCLK_SPEED 1
N#if FCLK_SPEED==0   					//  FCLK=203Mhz, Fin=12Mhz for AUDIO     
X#if 1==0   					
S	#define M_MDIV          0xc3
S	#define M_PDIV          0x4
S	#define M_SDIV          0x1
N#elif FCLK_SPEED==1 					// Fin = 12M FCLK = 202.8Mhz M_MDIV = 0xa1 M_PDIV = 0x3 M_SDIV = 0x1
X#elif 1==1 					
N	#define M_MDIV          0xa1
N	#define M_PDIV          0x3
N	#define M_SDIV          0x1
N#endif
N
N#define PWRST             GPIO0
N#define OFFRST            GPIO1
N#define WDRST             GPIO2
N#define POWEROFFLED1	  (0x2<<4)
N#define POWEROFFLED2  	  (0x4<<4)
N#define POWEROFFLED3  	  (0x8<<4)
N
N//USB Device Options
N#define USBDMA		TRUE
N#define USBDMA_DEMAND 	FALSE			// the downloadFileSize should be (64*n)
N#define BULK_PKT_SIZE	32
N
N#endif    //__OPTION_H__	 
N
L 14 "..\Common\Inc\2410lib.h" 2
N#include "register.h"
L 1 "..\Common\Inc\register.h" 1
N/*********************************************************************************************
N* File name	: register.h
N* Author	: embest
N* Descript	: S3C2410 Define Address Register 
N* History
N*********************************************************************************************/
N
N#ifndef _S3C2410_REG_H
N#define _S3C2410_REG_H
N
N#define GPIO(Nb)	(0x00000001 << Nb)
N#define GPIO0		GPIO (0)   // GPIO  [0]	
N#define GPIO1		GPIO (1)   // GPIO  [1]		
N#define GPIO2		GPIO (2)   // GPIO  [2]	
N#define GPIO3		GPIO (3)   // GPIO  [3]	
N#define GPIO4		GPIO (4)   // GPIO  [4]		
N#define GPIO5		GPIO (5)   // GPIO  [5]			
N#define GPIO6		GPIO (6)   // GPIO  [6]			
N#define GPIO7		GPIO (7)   // GPIO  [7]			
N#define GPIO8		GPIO (8)   // GPIO  [8]			
N#define GPIO9		GPIO (9)   // GPIO  [9]			
N#define GPIO10		GPIO (10)  // GPIO [10]				
N#define GPIO11		GPIO (11)  // GPIO [11]			
N#define GPIO12		GPIO (12)  // GPIO [12]			
N#define GPIO13		GPIO (13)  // GPIO [13]				
N#define GPIO14		GPIO (14)  // GPIO [14]			
N#define GPIO15		GPIO (15)  // GPIO [15]			
N#define GPIO16		GPIO (16)  // GPIO [16]				
N#define GPIO17		GPIO (17)  // GPIO [17]			
N
N
N#define INTMSK		0x4A000008
N#define INTPND		0x4A000010
N#define INTSUBMSK	0x4A00001C
N#define WTCON		0x53000000
N#define LOCKTIME	0x4C000000
N#define MPLLCON		0x4C000004
N#define UPLLCON		0x4C000008
N#define CLKDIVN		0x4C000014
N#define BWSCON		0x48000000
N#define REFRESH		0x48000024
N#define BANKSIZE	0x48000028
N#define GPFCON		0x56000050
N#define GPFDAT		0x56000054
N#define GPFUP		0x56000058
N
N#define MISCCR		0x56000080
N#define SCK_NORMAL	(0x7<<17)
N
N#define GSTATUS0	0x560000AC
N#define GSTATUS1	0x560000B0
N#define GSTATUS2	0x560000B4
N#define GSTATUS3	0x560000B8
N#define GSTATUS4	0x560000BC    
N
N#endif
L 15 "..\Common\Inc\2410lib.h" 2
N#include "2410addr.h"
L 1 "..\Common\Inc\2410addr.h" 1
N/*********************************************************************************************
N* File name	: 2410addr.h
N* Author	: embest
N* Descript	: S3C2410 Define Address Register 
N* History
N*			R.X.Huang, Programming modify, March 12, 2005
N*********************************************************************************************/
N
N#ifndef __2410ADDR_H__
N#define __2410ADDR_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "option.h"
N
N// Memory control 
N#define rBWSCON    (*(volatile unsigned *)0x48000000) //Bus width & wait status
N#define rBANKCON0  (*(volatile unsigned *)0x48000004) //Boot ROM control
N#define rBANKCON1  (*(volatile unsigned *)0x48000008) //BANK1 control
N#define rBANKCON2  (*(volatile unsigned *)0x4800000c) //BANK2 cControl
N#define rBANKCON3  (*(volatile unsigned *)0x48000010) //BANK3 control
N#define rBANKCON4  (*(volatile unsigned *)0x48000014) //BANK4 control
N#define rBANKCON5  (*(volatile unsigned *)0x48000018) //BANK5 control
N#define rBANKCON6  (*(volatile unsigned *)0x4800001c) //BANK6 control
N#define rBANKCON7  (*(volatile unsigned *)0x48000020) //BANK7 control
N#define rREFRESH   (*(volatile unsigned *)0x48000024) //DRAM/SDRAM refresh
N#define rBANKSIZE  (*(volatile unsigned *)0x48000028) //Flexible Bank Size
N#define rMRSRB6    (*(volatile unsigned *)0x4800002c) //Mode register set for SDRAM
N#define rMRSRB7    (*(volatile unsigned *)0x48000030) //Mode register set for SDRAM
N
N
N// USB Host
N
N
N// INTERRUPT
N#define rSRCPND     (*(volatile unsigned *)0x4a000000) //Interrupt request status
N#define rINTMOD     (*(volatile unsigned *)0x4a000004) //Interrupt mode control
N#define rINTMSK     (*(volatile unsigned *)0x4a000008) //Interrupt mask control
N#define rPRIORITY   (*(volatile unsigned *)0x4a00000c) //IRQ priority control
N#define rINTPND     (*(volatile unsigned *)0x4a000010) //Interrupt request status
N#define rINTOFFSET  (*(volatile unsigned *)0x4a000014) //Interruot request source offset
N#define rSUBSRCPND  (*(volatile unsigned *)0x4a000018) //Sub source pending
N#define rINTSUBMSK  (*(volatile unsigned *)0x4a00001c) //Interrupt sub mask
N
N
N// DMA
N#define rDISRC0     (*(volatile unsigned *)0x4b000000) //DMA 0 Initial source
N#define rDISRCC0    (*(volatile unsigned *)0x4b000004) //DMA 0 Initial source control
N#define rDIDST0     (*(volatile unsigned *)0x4b000008) //DMA 0 Initial Destination
N#define rDIDSTC0    (*(volatile unsigned *)0x4b00000c) //DMA 0 Initial Destination control
N#define rDCON0      (*(volatile unsigned *)0x4b000010) //DMA 0 Control
N#define rDSTAT0     (*(volatile unsigned *)0x4b000014) //DMA 0 Status
N#define rDCSRC0     (*(volatile unsigned *)0x4b000018) //DMA 0 Current source
N#define rDCDST0     (*(volatile unsigned *)0x4b00001c) //DMA 0 Current destination
N#define rDMASKTRIG0 (*(volatile unsigned *)0x4b000020) //DMA 0 Mask trigger
N
N#define rDISRC1     (*(volatile unsigned *)0x4b000040) //DMA 1 Initial source
N#define rDISRCC1    (*(volatile unsigned *)0x4b000044) //DMA 1 Initial source control
N#define rDIDST1     (*(volatile unsigned *)0x4b000048) //DMA 1 Initial Destination
N#define rDIDSTC1    (*(volatile unsigned *)0x4b00004c) //DMA 1 Initial Destination control
N#define rDCON1      (*(volatile unsigned *)0x4b000050) //DMA 1 Control
N#define rDSTAT1     (*(volatile unsigned *)0x4b000054) //DMA 1 Status
N#define rDCSRC1     (*(volatile unsigned *)0x4b000058) //DMA 1 Current source
N#define rDCDST1     (*(volatile unsigned *)0x4b00005c) //DMA 1 Current destination
N#define rDMASKTRIG1 (*(volatile unsigned *)0x4b000060) //DMA 1 Mask trigger
N
N#define rDISRC2     (*(volatile unsigned *)0x4b000080) //DMA 2 Initial source
N#define rDISRCC2    (*(volatile unsigned *)0x4b000084) //DMA 2 Initial source control
N#define rDIDST2     (*(volatile unsigned *)0x4b000088) //DMA 2 Initial Destination
N#define rDIDSTC2    (*(volatile unsigned *)0x4b00008c) //DMA 2 Initial Destination control
N#define rDCON2      (*(volatile unsigned *)0x4b000090) //DMA 2 Control
N#define rDSTAT2     (*(volatile unsigned *)0x4b000094) //DMA 2 Status
N#define rDCSRC2     (*(volatile unsigned *)0x4b000098) //DMA 2 Current source
N#define rDCDST2     (*(volatile unsigned *)0x4b00009c) //DMA 2 Current destination
N#define rDMASKTRIG2 (*(volatile unsigned *)0x4b0000a0) //DMA 2 Mask trigger
N
N#define rDISRC3     (*(volatile unsigned *)0x4b0000c0) //DMA 3 Initial source
N#define rDISRCC3    (*(volatile unsigned *)0x4b0000c4) //DMA 3 Initial source control
N#define rDIDST3     (*(volatile unsigned *)0x4b0000c8) //DMA 3 Initial Destination
N#define rDIDSTC3    (*(volatile unsigned *)0x4b0000cc) //DMA 3 Initial Destination control
N#define rDCON3      (*(volatile unsigned *)0x4b0000d0) //DMA 3 Control
N#define rDSTAT3     (*(volatile unsigned *)0x4b0000d4) //DMA 3 Status
N#define rDCSRC3     (*(volatile unsigned *)0x4b0000d8) //DMA 3 Current source
N#define rDCDST3     (*(volatile unsigned *)0x4b0000dc) //DMA 3 Current destination
N#define rDMASKTRIG3 (*(volatile unsigned *)0x4b0000e0) //DMA 3 Mask trigger
N
N
N// CLOCK & POWER MANAGEMENT
N#define rLOCKTIME   (*(volatile unsigned *)0x4c000000) //PLL lock time counter
N#define rMPLLCON    (*(volatile unsigned *)0x4c000004) //MPLL Control
N#define rUPLLCON    (*(volatile unsigned *)0x4c000008) //UPLL Control
N#define rCLKCON     (*(volatile unsigned *)0x4c00000c) //Clock generator control
N#define rCLKSLOW    (*(volatile unsigned *)0x4c000010) //Slow clock control
N#define rCLKDIVN    (*(volatile unsigned *)0x4c000014) //Clock divider control
N
N
N// LCD CONTROLLER
N#define rLCDCON1    (*(volatile unsigned *)0x4d000000) //LCD control 1
N#define rLCDCON2    (*(volatile unsigned *)0x4d000004) //LCD control 2
N#define rLCDCON3    (*(volatile unsigned *)0x4d000008) //LCD control 3
N#define rLCDCON4    (*(volatile unsigned *)0x4d00000c) //LCD control 4
N#define rLCDCON5    (*(volatile unsigned *)0x4d000010) //LCD control 5
N#define rLCDSADDR1  (*(volatile unsigned *)0x4d000014) //STN/TFT Frame buffer start address 1
N#define rLCDSADDR2  (*(volatile unsigned *)0x4d000018) //STN/TFT Frame buffer start address 2
N#define rLCDSADDR3  (*(volatile unsigned *)0x4d00001c) //STN/TFT Virtual screen address set
N#define rREDLUT     (*(volatile unsigned *)0x4d000020) //STN Red lookup table
N#define rGREENLUT   (*(volatile unsigned *)0x4d000024) //STN Green lookup table 
N#define rBLUELUT    (*(volatile unsigned *)0x4d000028) //STN Blue lookup table
N#define rDITHMODE   (*(volatile unsigned *)0x4d00004c) //STN Dithering mode
N#define rTPAL       (*(volatile unsigned *)0x4d000050) //TFT Temporary palette
N#define rLCDINTPND  (*(volatile unsigned *)0x4d000054) //LCD Interrupt pending
N#define rLCDSRCPND  (*(volatile unsigned *)0x4d000058) //LCD Interrupt source
N#define rLCDINTMSK  (*(volatile unsigned *)0x4d00005c) //LCD Interrupt mask
N#define rLPCSEL     (*(volatile unsigned *)0x4d000060) //LPC3600 Control
N#define PALETTE     0x4d000400                         //Palette start address
N
N
N// NAND flash
N#define rNFCONF     (*(volatile unsigned *)0x4e000000)      //NAND Flash configuration
N#define rNFCMD      (*(volatile UINT8T *)0x4e000004)            //NADD Flash command
N#define rNFADDR     (*(volatile UINT8T *)0x4e000008)            //NAND Flash address
N#define rNFDATA     (*(volatile UINT8T *)0x4e00000c)            //NAND Flash data
N#define rNFSTAT     (*(volatile unsigned *)0x4e000010)      //NAND Flash operation status
N#define rNFECC      (*(volatile unsigned *)0x4e000014)      //NAND Flash ECC
N#define rNFECC0     (*(volatile UINT8T  *)0x4e000014)
N#define rNFECC1     (*(volatile UINT8T  *)0x4e000015)
N#define rNFECC2     (*(volatile UINT8T  *)0x4e000016)
N
N// UART
N#define rULCON0     (*(volatile unsigned *)0x50000000) //UART 0 Line control
N#define rUCON0      (*(volatile unsigned *)0x50000004) //UART 0 Control
N#define rUFCON0     (*(volatile unsigned *)0x50000008) //UART 0 FIFO control
N#define rUMCON0     (*(volatile unsigned *)0x5000000c) //UART 0 Modem control
N#define rUTRSTAT0   (*(volatile unsigned *)0x50000010) //UART 0 Tx/Rx status
N#define rUERSTAT0   (*(volatile unsigned *)0x50000014) //UART 0 Rx error status
N#define rUFSTAT0    (*(volatile unsigned *)0x50000018) //UART 0 FIFO status
N#define rUMSTAT0    (*(volatile unsigned *)0x5000001c) //UART 0 Modem status
N#define rUBRDIV0    (*(volatile unsigned *)0x50000028) //UART 0 Baud rate divisor
N
N#define rULCON1     (*(volatile unsigned *)0x50004000) //UART 1 Line control
N#define rUCON1      (*(volatile unsigned *)0x50004004) //UART 1 Control
N#define rUFCON1     (*(volatile unsigned *)0x50004008) //UART 1 FIFO control
N#define rUMCON1     (*(volatile unsigned *)0x5000400c) //UART 1 Modem control
N#define rUTRSTAT1   (*(volatile unsigned *)0x50004010) //UART 1 Tx/Rx status
N#define rUERSTAT1   (*(volatile unsigned *)0x50004014) //UART 1 Rx error status
N#define rUFSTAT1    (*(volatile unsigned *)0x50004018) //UART 1 FIFO status
N#define rUMSTAT1    (*(volatile unsigned *)0x5000401c) //UART 1 Modem status
N#define rUBRDIV1    (*(volatile unsigned *)0x50004028) //UART 1 Baud rate divisor
N
N#define rULCON2     (*(volatile unsigned *)0x50008000) //UART 2 Line control
N#define rUCON2      (*(volatile unsigned *)0x50008004) //UART 2 Control
N#define rUFCON2     (*(volatile unsigned *)0x50008008) //UART 2 FIFO control
N#define rUMCON2     (*(volatile unsigned *)0x5000800c) //UART 2 Modem control
N#define rUTRSTAT2   (*(volatile unsigned *)0x50008010) //UART 2 Tx/Rx status
N#define rUERSTAT2   (*(volatile unsigned *)0x50008014) //UART 2 Rx error status
N#define rUFSTAT2    (*(volatile unsigned *)0x50008018) //UART 2 FIFO status
N#define rUMSTAT2    (*(volatile unsigned *)0x5000801c) //UART 2 Modem status
N#define rUBRDIV2    (*(volatile unsigned *)0x50008028) //UART 2 Baud rate divisor
N
N#ifdef __BIG_ENDIAN
S#define rUTXH0      (*(volatile unsigned char *)0x50000023) //UART 0 Transmission Hold
S#define rURXH0      (*(volatile unsigned char *)0x50000027) //UART 0 Receive buffer
S#define rUTXH1      (*(volatile unsigned char *)0x50004023) //UART 1 Transmission Hold
S#define rURXH1      (*(volatile unsigned char *)0x50004027) //UART 1 Receive buffer
S#define rUTXH2      (*(volatile unsigned char *)0x50008023) //UART 2 Transmission Hold
S#define rURXH2      (*(volatile unsigned char *)0x50008027) //UART 2 Receive buffer
S
S#define WrUTXH0(ch) (*(volatile unsigned char *)0x50000023)=(unsigned char)(ch)
S#define RdURXH0()   (*(volatile unsigned char *)0x50000027)
S#define WrUTXH1(ch) (*(volatile unsigned char *)0x50004023)=(unsigned char)(ch)
S#define RdURXH1()   (*(volatile unsigned char *)0x50004027)
S#define WrUTXH2(ch) (*(volatile unsigned char *)0x50008023)=(unsigned char)(ch)
S#define RdURXH2()   (*(volatile unsigned char *)0x50008027)
S
S#define UTXH0       (0x50000020+3)  //Byte_access address by DMA
S#define URXH0       (0x50000024+3)
S#define UTXH1       (0x50004020+3)
S#define URXH1       (0x50004024+3)
S#define UTXH2       (0x50008020+3)
S#define URXH2       (0x50008024+3)
S
N#else //Little Endian
N#define rUTXH0 (*(volatile unsigned char *)0x50000020) //UART 0 Transmission Hold
N#define rURXH0 (*(volatile unsigned char *)0x50000024) //UART 0 Receive buffer
N#define rUTXH1 (*(volatile unsigned char *)0x50004020) //UART 1 Transmission Hold
N#define rURXH1 (*(volatile unsigned char *)0x50004024) //UART 1 Receive buffer
N#define rUTXH2 (*(volatile unsigned char *)0x50008020) //UART 2 Transmission Hold
N#define rURXH2 (*(volatile unsigned char *)0x50008024) //UART 2 Receive buffer
N
N#define WrUTXH0(ch) (*(volatile unsigned char *)0x50000020)=(unsigned char)(ch)
N#define RdURXH0()   (*(volatile unsigned char *)0x50000024)
N#define WrUTXH1(ch) (*(volatile unsigned char *)0x50004020)=(unsigned char)(ch)
N#define RdURXH1()   (*(volatile unsigned char *)0x50004024)
N#define WrUTXH2(ch) (*(volatile unsigned char *)0x50008020)=(unsigned char)(ch)
N#define RdURXH2()   (*(volatile unsigned char *)0x50008024)
N
N#define UTXH0       (0x50000020)    //Byte_access address by DMA
N#define URXH0       (0x50000024)
N#define UTXH1       (0x50004020)
N#define URXH1       (0x50004024)
N#define UTXH2       (0x50008020)
N#define URXH2       (0x50008024)
N#endif
N
N
N// PWM TIMER
N#define rTCFG0  (*(volatile unsigned *)0x51000000) //Timer 0 configuration
N#define rTCFG1  (*(volatile unsigned *)0x51000004) //Timer 1 configuration
N#define rTCON   (*(volatile unsigned *)0x51000008) //Timer control
N#define rTCNTB0 (*(volatile unsigned *)0x5100000c) //Timer count buffer 0
N#define rTCMPB0 (*(volatile unsigned *)0x51000010) //Timer compare buffer 0
N#define rTCNTO0 (*(volatile unsigned *)0x51000014) //Timer count observation 0
N#define rTCNTB1 (*(volatile unsigned *)0x51000018) //Timer count buffer 1
N#define rTCMPB1 (*(volatile unsigned *)0x5100001c) //Timer compare buffer 1
N#define rTCNTO1 (*(volatile unsigned *)0x51000020) //Timer count observation 1
N#define rTCNTB2 (*(volatile unsigned *)0x51000024) //Timer count buffer 2
N#define rTCMPB2 (*(volatile unsigned *)0x51000028) //Timer compare buffer 2
N#define rTCNTO2 (*(volatile unsigned *)0x5100002c) //Timer count observation 2
N#define rTCNTB3 (*(volatile unsigned *)0x51000030) //Timer count buffer 3
N#define rTCMPB3 (*(volatile unsigned *)0x51000034) //Timer compare buffer 3
N#define rTCNTO3 (*(volatile unsigned *)0x51000038) //Timer count observation 3
N#define rTCNTB4 (*(volatile unsigned *)0x5100003c) //Timer count buffer 4
N#define rTCNTO4 (*(volatile unsigned *)0x51000040) //Timer count observation 4
N
N
N// USB DEVICE
N#ifdef __BIG_ENDIAN
S<ERROR IF BIG_ENDIAN>
S#define rFUNC_ADDR_REG     (*(volatile unsigned char *)0x52000143) //Function address
S#define rPWR_REG           (*(volatile unsigned char *)0x52000147) //Power management
S#define rEP_INT_REG        (*(volatile unsigned char *)0x5200014b) //EP Interrupt pending and clear
S#define rUSB_INT_REG       (*(volatile unsigned char *)0x5200015b) //USB Interrupt pending and clear
S#define rEP_INT_EN_REG     (*(volatile unsigned char *)0x5200015f) //Interrupt enable
S#define rUSB_INT_EN_REG    (*(volatile unsigned char *)0x5200016f)
S#define rFRAME_NUM1_REG    (*(volatile unsigned char *)0x52000173) //Frame number lower byte
S#define rFRAME_NUM2_REG    (*(volatile unsigned char *)0x52000177) //Frame number higher byte
S#define rINDEX_REG         (*(volatile unsigned char *)0x5200017b) //Register index
S#define rMAXP_REG          (*(volatile unsigned char *)0x52000183) //Endpoint max packet
S#define rEP0_CSR           (*(volatile unsigned char *)0x52000187) //Endpoint 0 status
S#define rIN_CSR1_REG       (*(volatile unsigned char *)0x52000187) //In endpoint control status
S#define rIN_CSR2_REG       (*(volatile unsigned char *)0x5200018b)
S#define rOUT_CSR1_REG      (*(volatile unsigned char *)0x52000193) //Out endpoint control status
S#define rOUT_CSR2_REG      (*(volatile unsigned char *)0x52000197)
S#define rOUT_FIFO_CNT1_REG (*(volatile unsigned char *)0x5200019b) //Endpoint out write count
S#define rOUT_FIFO_CNT2_REG (*(volatile unsigned char *)0x5200019f)
S#define rEP0_FIFO          (*(volatile unsigned char *)0x520001c3) //Endpoint 0 FIFO
S#define rEP1_FIFO          (*(volatile unsigned char *)0x520001c7) //Endpoint 1 FIFO
S#define rEP2_FIFO          (*(volatile unsigned char *)0x520001cb) //Endpoint 2 FIFO
S#define rEP3_FIFO          (*(volatile unsigned char *)0x520001cf) //Endpoint 3 FIFO
S#define rEP4_FIFO          (*(volatile unsigned char *)0x520001d3) //Endpoint 4 FIFO
S#define rEP1_DMA_CON       (*(volatile unsigned char *)0x52000203) //EP1 DMA interface control
S#define rEP1_DMA_UNIT      (*(volatile unsigned char *)0x52000207) //EP1 DMA Tx unit counter
S#define rEP1_DMA_FIFO      (*(volatile unsigned char *)0x5200020b) //EP1 DMA Tx FIFO counter
S#define rEP1_DMA_TTC_L     (*(volatile unsigned char *)0x5200020f) //EP1 DMA total Tx counter
S#define rEP1_DMA_TTC_M     (*(volatile unsigned char *)0x52000213)
S#define rEP1_DMA_TTC_H     (*(volatile unsigned char *)0x52000217)
S#define rEP2_DMA_CON       (*(volatile unsigned char *)0x5200021b) //EP2 DMA interface control
S#define rEP2_DMA_UNIT      (*(volatile unsigned char *)0x5200021f) //EP2 DMA Tx unit counter
S#define rEP2_DMA_FIFO      (*(volatile unsigned char *)0x52000223) //EP2 DMA Tx FIFO counter
S#define rEP2_DMA_TTC_L     (*(volatile unsigned char *)0x52000227) //EP2 DMA total Tx counter
S#define rEP2_DMA_TTC_M     (*(volatile unsigned char *)0x5200022b)
S#define rEP2_DMA_TTC_H     (*(volatile unsigned char *)0x5200022f)
S#define rEP3_DMA_CON       (*(volatile unsigned char *)0x52000243) //EP3 DMA interface control
S#define rEP3_DMA_UNIT      (*(volatile unsigned char *)0x52000247) //EP3 DMA Tx unit counter
S#define rEP3_DMA_FIFO      (*(volatile unsigned char *)0x5200024b) //EP3 DMA Tx FIFO counter
S#define rEP3_DMA_TTC_L     (*(volatile unsigned char *)0x5200024f) //EP3 DMA total Tx counter
S#define rEP3_DMA_TTC_M     (*(volatile unsigned char *)0x52000253)
S#define rEP3_DMA_TTC_H     (*(volatile unsigned char *)0x52000257)
S#define rEP4_DMA_CON       (*(volatile unsigned char *)0x5200025b) //EP4 DMA interface control
S#define rEP4_DMA_UNIT      (*(volatile unsigned char *)0x5200025f) //EP4 DMA Tx unit counter
S#define rEP4_DMA_FIFO      (*(volatile unsigned char *)0x52000263) //EP4 DMA Tx FIFO counter
S#define rEP4_DMA_TTC_L     (*(volatile unsigned char *)0x52000267) //EP4 DMA total Tx counter
S#define rEP4_DMA_TTC_M     (*(volatile unsigned char *)0x5200026b)
S#define rEP4_DMA_TTC_H     (*(volatile unsigned char *)0x5200026f)
S
N#else  // Little Endian
N#define rFUNC_ADDR_REG     (*(volatile unsigned char *)0x52000140) //Function address
N#define rPWR_REG           (*(volatile unsigned char *)0x52000144) //Power management
N#define rEP_INT_REG        (*(volatile unsigned char *)0x52000148) //EP Interrupt pending and clear
N#define rUSB_INT_REG       (*(volatile unsigned char *)0x52000158) //USB Interrupt pending and clear
N#define rEP_INT_EN_REG     (*(volatile unsigned char *)0x5200015c) //Interrupt enable
N#define rUSB_INT_EN_REG    (*(volatile unsigned char *)0x5200016c)
N#define rFRAME_NUM1_REG    (*(volatile unsigned char *)0x52000170) //Frame number lower byte
N#define rFRAME_NUM2_REG    (*(volatile unsigned char *)0x52000174) //Frame number higher byte
N#define rINDEX_REG         (*(volatile unsigned char *)0x52000178) //Register index
N#define rMAXP_REG          (*(volatile unsigned char *)0x52000180) //Endpoint max packet
N#define rEP0_CSR           (*(volatile unsigned char *)0x52000184) //Endpoint 0 status
N#define rIN_CSR1_REG       (*(volatile unsigned char *)0x52000184) //In endpoint control status
N#define rIN_CSR2_REG       (*(volatile unsigned char *)0x52000188)
N#define rOUT_CSR1_REG      (*(volatile unsigned char *)0x52000190) //Out endpoint control status
N#define rOUT_CSR2_REG      (*(volatile unsigned char *)0x52000194)
N#define rOUT_FIFO_CNT1_REG (*(volatile unsigned char *)0x52000198) //Endpoint out write count
N#define rOUT_FIFO_CNT2_REG (*(volatile unsigned char *)0x5200019c)
N#define rEP0_FIFO          (*(volatile unsigned char *)0x520001c0) //Endpoint 0 FIFO
N#define rEP1_FIFO          (*(volatile unsigned char *)0x520001c4) //Endpoint 1 FIFO
N#define rEP2_FIFO          (*(volatile unsigned char *)0x520001c8) //Endpoint 2 FIFO
N#define rEP3_FIFO          (*(volatile unsigned char *)0x520001cc) //Endpoint 3 FIFO
N#define rEP4_FIFO          (*(volatile unsigned char *)0x520001d0) //Endpoint 4 FIFO
N#define rEP1_DMA_CON       (*(volatile unsigned char *)0x52000200) //EP1 DMA interface control
N#define rEP1_DMA_UNIT      (*(volatile unsigned char *)0x52000204) //EP1 DMA Tx unit counter
N#define rEP1_DMA_FIFO      (*(volatile unsigned char *)0x52000208) //EP1 DMA Tx FIFO counter
N#define rEP1_DMA_TTC_L     (*(volatile unsigned char *)0x5200020c) //EP1 DMA total Tx counter
N#define rEP1_DMA_TTC_M     (*(volatile unsigned char *)0x52000210)
N#define rEP1_DMA_TTC_H     (*(volatile unsigned char *)0x52000214)
N#define rEP2_DMA_CON       (*(volatile unsigned char *)0x52000218) //EP2 DMA interface control
N#define rEP2_DMA_UNIT      (*(volatile unsigned char *)0x5200021c) //EP2 DMA Tx unit counter
N#define rEP2_DMA_FIFO      (*(volatile unsigned char *)0x52000220) //EP2 DMA Tx FIFO counter
N#define rEP2_DMA_TTC_L     (*(volatile unsigned char *)0x52000224) //EP2 DMA total Tx counter
N#define rEP2_DMA_TTC_M     (*(volatile unsigned char *)0x52000228)
N#define rEP2_DMA_TTC_H     (*(volatile unsigned char *)0x5200022c)
N#define rEP3_DMA_CON       (*(volatile unsigned char *)0x52000240) //EP3 DMA interface control
N#define rEP3_DMA_UNIT      (*(volatile unsigned char *)0x52000244) //EP3 DMA Tx unit counter
N#define rEP3_DMA_FIFO      (*(volatile unsigned char *)0x52000248) //EP3 DMA Tx FIFO counter
N#define rEP3_DMA_TTC_L     (*(volatile unsigned char *)0x5200024c) //EP3 DMA total Tx counter
N#define rEP3_DMA_TTC_M     (*(volatile unsigned char *)0x52000250)
N#define rEP3_DMA_TTC_H     (*(volatile unsigned char *)0x52000254)
N#define rEP4_DMA_CON       (*(volatile unsigned char *)0x52000258) //EP4 DMA interface control
N#define rEP4_DMA_UNIT      (*(volatile unsigned char *)0x5200025c) //EP4 DMA Tx unit counter
N#define rEP4_DMA_FIFO      (*(volatile unsigned char *)0x52000260) //EP4 DMA Tx FIFO counter
N#define rEP4_DMA_TTC_L     (*(volatile unsigned char *)0x52000264) //EP4 DMA total Tx counter
N#define rEP4_DMA_TTC_M     (*(volatile unsigned char *)0x52000268)
N#define rEP4_DMA_TTC_H     (*(volatile unsigned char *)0x5200026c)
N#endif   // __BIG_ENDIAN
N
N
N// WATCH DOG TIMER
N#define rWTCON   (*(volatile unsigned *)0x53000000) //Watch-dog timer mode
N#define rWTDAT   (*(volatile unsigned *)0x53000004) //Watch-dog timer data
N#define rWTCNT   (*(volatile unsigned *)0x53000008) //Eatch-dog timer count
N
N
N// IIC
N#define rIICCON  (*(volatile unsigned *)0x54000000) //IIC control
N#define rIICSTAT (*(volatile unsigned *)0x54000004) //IIC status
N#define rIICADD  (*(volatile unsigned *)0x54000008) //IIC address
N#define rIICDS   (*(volatile unsigned *)0x5400000c) //IIC data shift
N
N
N// IIS
N#define rIISCON  (*(volatile unsigned *)0x55000000) //IIS Control
N#define rIISMOD  (*(volatile unsigned *)0x55000004) //IIS Mode
N#define rIISPSR  (*(volatile unsigned *)0x55000008) //IIS Prescaler
N#define rIISFCON (*(volatile unsigned *)0x5500000c) //IIS FIFO control
N
N#ifdef __BIG_ENDIAN
S#define IISFIFO  ((volatile unsigned short *)0x55000012) //IIS FIFO entry
S
N#else //Little Endian
N#define IISFIFO  ((volatile unsigned short *)0x55000010) //IIS FIFO entry
N
N#endif
N
N
N// I/O PORT 
N#define rGPACON    (*(volatile unsigned *)0x56000000) //Port A control
N#define rGPADAT    (*(volatile unsigned *)0x56000004) //Port A data
N                        
N#define rGPBCON    (*(volatile unsigned *)0x56000010) //Port B control
N#define rGPBDAT    (*(volatile unsigned *)0x56000014) //Port B data
N#define rGPBUP     (*(volatile unsigned *)0x56000018) //Pull-up control B
N                        
N#define rGPCCON    (*(volatile unsigned *)0x56000020) //Port C control
N#define rGPCDAT    (*(volatile unsigned *)0x56000024) //Port C data
N#define rGPCUP     (*(volatile unsigned *)0x56000028) //Pull-up control C
N                        
N#define rGPDCON    (*(volatile unsigned *)0x56000030) //Port D control
N#define rGPDDAT    (*(volatile unsigned *)0x56000034) //Port D data
N#define rGPDUP     (*(volatile unsigned *)0x56000038) //Pull-up control D
N                        
N#define rGPECON    (*(volatile unsigned *)0x56000040) //Port E control
N#define rGPEDAT    (*(volatile unsigned *)0x56000044) //Port E data
N#define rGPEUP     (*(volatile unsigned *)0x56000048) //Pull-up control E
N                        
N#define rGPFCON    (*(volatile unsigned *)0x56000050) //Port F control
N#define rGPFDAT    (*(volatile unsigned *)0x56000054) //Port F data
N#define rGPFUP     (*(volatile unsigned *)0x56000058) //Pull-up control F
N                        
N#define rGPGCON    (*(volatile unsigned *)0x56000060) //Port G control
N#define rGPGDAT    (*(volatile unsigned *)0x56000064) //Port G data
N#define rGPGUP     (*(volatile unsigned *)0x56000068) //Pull-up control G
N                        
N#define rGPHCON    (*(volatile unsigned *)0x56000070) //Port H control
N#define rGPHDAT    (*(volatile unsigned *)0x56000074) //Port H data
N#define rGPHUP     (*(volatile unsigned *)0x56000078) //Pull-up control H
N                        
N#define rMISCCR    (*(volatile unsigned *)0x56000080) //Miscellaneous control
N#define rDCLKCON   (*(volatile unsigned *)0x56000084) //DCLK0/1 control
N#define rEXTINT0   (*(volatile unsigned *)0x56000088) //External interrupt control register 0
N#define rEXTINT1   (*(volatile unsigned *)0x5600008c) //External interrupt control register 1
N#define rEXTINT2   (*(volatile unsigned *)0x56000090) //External interrupt control register 2
N#define rEINTFLT0  (*(volatile unsigned *)0x56000094) //Reserved
N#define rEINTFLT1  (*(volatile unsigned *)0x56000098) //Reserved
N#define rEINTFLT2  (*(volatile unsigned *)0x5600009c) //External interrupt filter control register 2
N#define rEINTFLT3  (*(volatile unsigned *)0x560000a0) //External interrupt filter control register 3
N#define rEINTMASK  (*(volatile unsigned *)0x560000a4) //External interrupt mask
N#define rEINTPEND  (*(volatile unsigned *)0x560000a8) //External interrupt pending
N#define rGSTATUS0  (*(volatile unsigned *)0x560000ac) //External pin status
N#define rGSTATUS1  (*(volatile unsigned *)0x560000b0) //Chip ID(0x32410000)
N#define rGSTATUS2  (*(volatile unsigned *)0x560000b4) //Reset type
N#define rGSTATUS3  (*(volatile unsigned *)0x560000b8) //Saved data0(32-bit) before entering POWER_OFF mode 
N#define rGSTATUS4  (*(volatile unsigned *)0x560000bc) //Saved data0(32-bit) before entering POWER_OFF mode 
N
N
N// RTC
N#ifdef __BIG_ENDIAN
S#define rRTCCON    (*(volatile unsigned char *)0x57000043) //RTC control
S#define rTICNT     (*(volatile unsigned char *)0x57000047) //Tick time count
S#define rRTCALM    (*(volatile unsigned char *)0x57000053) //RTC alarm control
S#define rALMSEC    (*(volatile unsigned char *)0x57000057) //Alarm second
S#define rALMMIN    (*(volatile unsigned char *)0x5700005b) //Alarm minute
S#define rALMHOUR   (*(volatile unsigned char *)0x5700005f) //Alarm Hour
S#define rALMDATE   (*(volatile unsigned char *)0x57000063) //Alarm day     <-- May 06, 2002 SOP
S#define rALMMON    (*(volatile unsigned char *)0x57000067) //Alarm month
S#define rALMYEAR   (*(volatile unsigned char *)0x5700006b) //Alarm year
S#define rRTCRST    (*(volatile unsigned char *)0x5700006f) //RTC round reset
S#define rBCDSEC    (*(volatile unsigned char *)0x57000073) //BCD second
S#define rBCDMIN    (*(volatile unsigned char *)0x57000077) //BCD minute
S#define rBCDHOUR   (*(volatile unsigned char *)0x5700007b) //BCD hour
S#define rBCDDATE   (*(volatile unsigned char *)0x5700007f) //BCD day       <-- May 06, 2002 SOP
S#define rBCDDAY    (*(volatile unsigned char *)0x57000083) //BCD date      <-- May 06, 2002 SOP
S#define rBCDMON    (*(volatile unsigned char *)0x57000087) //BCD month
S#define rBCDYEAR   (*(volatile unsigned char *)0x5700008b) //BCD year
S
N#else //Little Endian
N#define rRTCCON    (*(volatile unsigned char *)0x57000040) //RTC control
N#define rTICNT     (*(volatile unsigned char *)0x57000044) //Tick time count
N#define rRTCALM    (*(volatile unsigned char *)0x57000050) //RTC alarm control
N#define rALMSEC    (*(volatile unsigned char *)0x57000054) //Alarm second
N#define rALMMIN    (*(volatile unsigned char *)0x57000058) //Alarm minute
N#define rALMHOUR   (*(volatile unsigned char *)0x5700005c) //Alarm Hour
N#define rALMDATE   (*(volatile unsigned char *)0x57000060) //Alarm day      <-- May 06, 2002 SOP
N#define rALMMON    (*(volatile unsigned char *)0x57000064) //Alarm month
N#define rALMYEAR   (*(volatile unsigned char *)0x57000068) //Alarm year
N#define rRTCRST    (*(volatile unsigned char *)0x5700006c) //RTC round reset
N#define rBCDSEC    (*(volatile unsigned char *)0x57000070) //BCD second
N#define rBCDMIN    (*(volatile unsigned char *)0x57000074) //BCD minute
N#define rBCDHOUR   (*(volatile unsigned char *)0x57000078) //BCD hour
N#define rBCDDATE   (*(volatile unsigned char *)0x5700007c) //BCD day        <-- May 06, 2002 SOP
N#define rBCDDAY    (*(volatile unsigned char *)0x57000080) //BCD date       <-- May 06, 2002 SOP
N#define rBCDMON    (*(volatile unsigned char *)0x57000084) //BCD month
N#define rBCDYEAR   (*(volatile unsigned char *)0x57000088) //BCD year
N#endif  //RTC
N
N
N// ADC
N#define rADCCON    (*(volatile unsigned *)0x58000000) //ADC control
N#define rADCTSC    (*(volatile unsigned *)0x58000004) //ADC touch screen control
N#define rADCDLY    (*(volatile unsigned *)0x58000008) //ADC start or Interval Delay
N#define rADCDAT0   (*(volatile unsigned *)0x5800000c) //ADC conversion data 0
N#define rADCDAT1   (*(volatile unsigned *)0x58000010) //ADC conversion data 1                   
N                        
N// SPI          
N#define rSPCON0    (*(volatile unsigned *)0x59000000) //SPI0 control
N#define rSPSTA0    (*(volatile unsigned *)0x59000004) //SPI0 status
N#define rSPPIN0    (*(volatile unsigned *)0x59000008) //SPI0 pin control
N#define rSPPRE0    (*(volatile unsigned *)0x5900000c) //SPI0 baud rate prescaler
N#define rSPTDAT0   (*(volatile unsigned *)0x59000010) //SPI0 Tx data
N#define rSPRDAT0   (*(volatile unsigned *)0x59000014) //SPI0 Rx data
N
N#define rSPCON1    (*(volatile unsigned *)0x59000020) //SPI1 control
N#define rSPSTA1    (*(volatile unsigned *)0x59000024) //SPI1 status
N#define rSPPIN1    (*(volatile unsigned *)0x59000028) //SPI1 pin control
N#define rSPPRE1    (*(volatile unsigned *)0x5900002c) //SPI1 baud rate prescaler
N#define rSPTDAT1   (*(volatile unsigned *)0x59000030) //SPI1 Tx data
N#define rSPRDAT1   (*(volatile unsigned *)0x59000034) //SPI1 Rx data
N
N
N// SD Interface
N#define rSDICON     (*(volatile unsigned *)0x5a000000) //SDI control
N#define rSDIPRE     (*(volatile unsigned *)0x5a000004) //SDI baud rate prescaler
N#define rSDICARG    (*(volatile unsigned *)0x5a000008) //SDI command argument
N#define rSDICCON    (*(volatile unsigned *)0x5a00000c) //SDI command control
N#define rSDICSTA    (*(volatile unsigned *)0x5a000010) //SDI command status
N#define rSDIRSP0    (*(volatile unsigned *)0x5a000014) //SDI response 0
N#define rSDIRSP1    (*(volatile unsigned *)0x5a000018) //SDI response 1
N#define rSDIRSP2    (*(volatile unsigned *)0x5a00001c) //SDI response 2
N#define rSDIRSP3    (*(volatile unsigned *)0x5a000020) //SDI response 3
N#define rSDIDTIMER  (*(volatile unsigned *)0x5a000024) //SDI data/busy timer
N#define rSDIBSIZE   (*(volatile unsigned *)0x5a000028) //SDI block size
N#define rSDIDCON    (*(volatile unsigned *)0x5a00002c) //SDI data control
N#define rSDIDCNT    (*(volatile unsigned *)0x5a000030) //SDI data remain counter
N#define rSDIDSTA    (*(volatile unsigned *)0x5a000034) //SDI data status
N#define rSDIFSTA    (*(volatile unsigned *)0x5a000038) //SDI FIFO status
N#define rSDIIMSK    (*(volatile unsigned *)0x5a000040) //SDI interrupt mask
N
N#ifdef __BIG_ENDIAN
S#define rSDIDAT    (*(volatile unsigned *)0x5a00003f) //SDI data
S#define SDIDAT     0x5a00003f
N#else  // Little Endian
N#define rSDIDAT    (*(volatile unsigned *)0x5a00003c) //SDI data
N#define SDIDAT     0x5a00003c
N#endif   //SD Interface
N             
N#define _ISR_STARTADDRESS 0x33ffff00
N// ISR
N#define pISR_RESET     (*(unsigned *)(_ISR_STARTADDRESS+0x0))
N#define pISR_UNDEF     (*(unsigned *)(_ISR_STARTADDRESS+0x4))
N#define pISR_SWI       (*(unsigned *)(_ISR_STARTADDRESS+0x8))
N#define pISR_PABORT    (*(unsigned *)(_ISR_STARTADDRESS+0xc))
N#define pISR_DABORT    (*(unsigned *)(_ISR_STARTADDRESS+0x10))
N#define pISR_RESERVED  (*(unsigned *)(_ISR_STARTADDRESS+0x14))
N#define pISR_IRQ       (*(unsigned *)(_ISR_STARTADDRESS+0x18))
N#define pISR_FIQ       (*(unsigned *)(_ISR_STARTADDRESS+0x1c))
N
N#define pISR_EINT0     (*(unsigned *)(_ISR_STARTADDRESS+0x20))
N#define pISR_EINT1     (*(unsigned *)(_ISR_STARTADDRESS+0x24))
N#define pISR_EINT2     (*(unsigned *)(_ISR_STARTADDRESS+0x28))
N#define pISR_EINT3     (*(unsigned *)(_ISR_STARTADDRESS+0x2c))
N#define pISR_EINT4_7   (*(unsigned *)(_ISR_STARTADDRESS+0x30))
N#define pISR_EINT8_23  (*(unsigned *)(_ISR_STARTADDRESS+0x34))
N#define pISR_NOTUSED6  (*(unsigned *)(_ISR_STARTADDRESS+0x38))
N#define pISR_BAT_FLT   (*(unsigned *)(_ISR_STARTADDRESS+0x3c))
N#define pISR_TICK      (*(unsigned *)(_ISR_STARTADDRESS+0x40))
N#define pISR_WDT       (*(unsigned *)(_ISR_STARTADDRESS+0x44))
N#define pISR_TIMER0    (*(unsigned *)(_ISR_STARTADDRESS+0x48))
N#define pISR_TIMER1    (*(unsigned *)(_ISR_STARTADDRESS+0x4c))
N#define pISR_TIMER2    (*(unsigned *)(_ISR_STARTADDRESS+0x50))
N#define pISR_TIMER3    (*(unsigned *)(_ISR_STARTADDRESS+0x54))
N#define pISR_TIMER4    (*(unsigned *)(_ISR_STARTADDRESS+0x58))
N#define pISR_UART2     (*(unsigned *)(_ISR_STARTADDRESS+0x5c))
N#define pISR_LCD       (*(unsigned *)(_ISR_STARTADDRESS+0x60))
N#define pISR_DMA0      (*(unsigned *)(_ISR_STARTADDRESS+0x64))
N#define pISR_DMA1      (*(unsigned *)(_ISR_STARTADDRESS+0x68))
N#define pISR_DMA2      (*(unsigned *)(_ISR_STARTADDRESS+0x6c))
N#define pISR_DMA3      (*(unsigned *)(_ISR_STARTADDRESS+0x70))
N#define pISR_SDI       (*(unsigned *)(_ISR_STARTADDRESS+0x74))
N#define pISR_SPI0      (*(unsigned *)(_ISR_STARTADDRESS+0x78))
N#define pISR_UART1     (*(unsigned *)(_ISR_STARTADDRESS+0x7c))
N#define pISR_NOTUSED24 (*(unsigned *)(_ISR_STARTADDRESS+0x80))
N#define pISR_USBD      (*(unsigned *)(_ISR_STARTADDRESS+0x84))
N#define pISR_USBH      (*(unsigned *)(_ISR_STARTADDRESS+0x88))
N#define pISR_IIC       (*(unsigned *)(_ISR_STARTADDRESS+0x8c))
N#define pISR_UART0     (*(unsigned *)(_ISR_STARTADDRESS+0x90))
N#define pISR_SPI1      (*(unsigned *)(_ISR_STARTADDRESS+0x94))
N#define pISR_RTC       (*(unsigned *)(_ISR_STARTADDRESS+0x98))
N#define pISR_ADC       (*(unsigned *)(_ISR_STARTADDRESS+0x9c))
N
N
N// PENDING BIT
N#define BIT_EINT0      (0x1)
N#define BIT_EINT1      (0x1<<1)
N#define BIT_EINT2      (0x1<<2)
N#define BIT_EINT3      (0x1<<3)
N#define BIT_EINT4_7    (0x1<<4)
N#define BIT_EINT8_23   (0x1<<5)
N#define BIT_NOTUSED6   (0x1<<6)
N#define BIT_BAT_FLT    (0x1<<7)
N#define BIT_TICK       (0x1<<8)
N#define BIT_WDT        (0x1<<9)
N#define BIT_TIMER0     (0x1<<10)
N#define BIT_TIMER1     (0x1<<11)
N#define BIT_TIMER2     (0x1<<12)
N#define BIT_TIMER3     (0x1<<13)
N#define BIT_TIMER4     (0x1<<14)
N#define BIT_UART2      (0x1<<15)
N#define BIT_LCD        (0x1<<16)
N#define BIT_DMA0       (0x1<<17)
N#define BIT_DMA1       (0x1<<18)
N#define BIT_DMA2       (0x1<<19)
N#define BIT_DMA3       (0x1<<20)
N#define BIT_SDI        (0x1<<21)
N#define BIT_SPI0       (0x1<<22)
N#define BIT_UART1      (0x1<<23)
N#define BIT_NOTUSED24  (0x1<<24)
N#define BIT_USBD       (0x1<<25)
N#define BIT_USBH       (0x1<<26)
N#define BIT_IIC        (0x1<<27)
N#define BIT_UART0      (0x1<<28)
N#define BIT_SPI1       (0x1<<29)
N#define BIT_RTC        (0x1<<30)
N#define BIT_ADC        (0x80000000) //(0x1<<31)
N#define BIT_ALLMSK     (0xffffffff)
N
N#define BIT_SUB_ALLMSK (0x7ff)
N#define BIT_SUB_ADC    (0x1<<10)
N#define BIT_SUB_TC     (0x1<<9)
N#define BIT_SUB_ERR2   (0x1<<8)
N#define BIT_SUB_TXD2   (0x1<<7)
N#define BIT_SUB_RXD2   (0x1<<6)
N#define BIT_SUB_ERR1   (0x1<<5)
N#define BIT_SUB_TXD1   (0x1<<4)
N#define BIT_SUB_RXD1   (0x1<<3)
N#define BIT_SUB_ERR0   (0x1<<2)
N#define BIT_SUB_TXD0   (0x1<<1)
N#define BIT_SUB_RXD0   (0x1<<0)
N
N#define ClearPending(bit) {\
N                rSRCPND = bit;\
N                rINTPND = rINTPND;} // precent write wrong data
X#define ClearPending(bit) {                rSRCPND = bit;                rINTPND = rINTPND;} 
N
N//Wait until rINTPND is changed for the case that the ISR is very short.
N
N#ifdef __cplusplus
S}
N#endif
N#endif  //__2410ADDR_H___
N
L 16 "..\Common\Inc\2410lib.h" 2
N
N#ifndef __2410lib_h__
N#define __2410lib_h__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*------------------------------------------------------------------------------------------*/
N/*	 								constant define						 				    */
N/*------------------------------------------------------------------------------------------*/
N#define DOWNLOAD_ADDRESS _RAM_STARTADDRESS
N#define DEBUG_OUT uart_printf
N
N#define min(x1,x2) (((x1)<(x2))? (x1):(x2))
N#define max(x1,x2) (((x1)>(x2))? (x1):(x2))
N
N#define ONESEC0 (62500)								// 16us resolution, max 1.04 sec
N#define ONESEC1 (31250)								// 32us resolution, max 2.09 sec
N#define ONESEC2 (15625)								// 64us resolution, max 4.19 sec
N#define ONESEC3 (7812)								// 128us resolution, max 8.38 sec
N#define ONESEC4 (PCLK/128/(0xff+1))					// @60Mhz, 128*4us resolution, max 32.53 sec
N
N#define NULL 0
N#define LCD   0xDD									// LCD symbol
N#define UART0 0x0									// UART symbol
N#define UART1 0x1
N#define UART2 0xBB
N#define EnterPWDN(clkcon) ((void (*)(int))0x20)(clkcon)
N
N/*------------------------------------------------------------------------------------------*/
N/*	 								fuction declare						 				    */
N/*------------------------------------------------------------------------------------------*/
Nvoid StartPointAfterPowerOffWakeUp(void);  
Nvoid sys_init(void);
Nvoid delay(int time);								// Watchdog Timer is used.
Nvoid port_init(void);
Nvoid uart_select(int ch);
Nvoid uart_txempty(int ch);
Nvoid uart_init(int nMainClk, int nBaud, int nChannel);
Nchar uart_getch(void);
Nchar uart_getkey(void);
Nint  uart_getintnum(void);
Nvoid uart_sendbyte(int data);
Nvoid uart_printf(char *fmt,...);
Nvoid uart_sendstring(char *pt);
Nvoid timer_start(int divider);						// Watchdog Timer is used.
Nint  timer_stop(void);								// Watchdog Timer is used.
N
Nvoid led_display(int data);
N
Nvoid change_value_MPLL(int m,int p,int s);
Nvoid change_clock_divider(int hdivn,int pdivn);
Nvoid ChangeUPllValue(int m,int p,int s);
Nvoid InitMMU(unsigned int *pTranslationTable);		
N
N/*------------------------------------------------------------------------------------------*/
N/*	 								inline fuction define								    */
N/*------------------------------------------------------------------------------------------*/
N/*********************************************************************************************
N* name:		ARM_WriteTTB
N* func:		Write Translation table base  register
N* para:		TTB Address
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
N__inline void ARM_WriteTTB(unsigned int ttb)
N{
N 	__asm("MCR p15, 0, (ttb & 0xFFFFC000), c2, c0, 0");
N}
N
N/*********************************************************************************************
N* name:		ARM_WriteDomain
N* func:		Write domain access control
N* para:		Domain NO.
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
N__inline void ARM_WriteDomain(unsigned int domain)
N{
N 	__asm("MCR p15, 0, domain, c3, c0, 0");
N}
N
N/*********************************************************************************************
N* name:		ARM_ReadControl
N* func:		Read Control register
N* para:		none
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
N__inline unsigned int ARM_ReadControl()
N{
N	register unsigned int ctl;
N 	__asm("MRC p15, 0, ctl, c1, c0, 0");
N 	return ctl;
N}
N
N/*********************************************************************************************
N* name:		ARM_WriteControl
N* func:		Write Control register
N* para:		Control Byte
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
N__inline void ARM_WriteControl(unsigned int ctl)
N{
N 	__asm("MCR p15, 0, ctl, c1, c0, 0");
N}
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif  //__2410lib_h__
N
L 17 "..\common\src\2410lib.c" 2
N#include "2410slib.h" 
L 1 "..\Common\Inc\2410slib.h" 1
N/*********************************************************************************************
N* File name	: 2410slib.h
N* Author	: embest
N* Descript	: S3C2410 MMU operation functions 
N* History
N*********************************************************************************************/
N
N#ifndef __2410slib_h__
N#define __2410slib_h__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* ********************************************************************* */
N/* Interface macro & data definition */
N
N#define DESC_SEC       (0x2|(1<<4))
N#define CB             (3<<2)  //cache_on, write_back
N#define CNB            (2<<2)  //cache_on, write_through 
N#define NCB            (1<<2)  //cache_off,WR_BUF on
N#define NCNB           (0<<2)  //cache_off,WR_BUF off
N#define AP_RW          (3<<10) //supervisor=RW, user=RW
N#define AP_RO          (2<<10) //supervisor=RW, user=RO
N
N#define DOMAIN_FAULT   (0x0)
N#define DOMAIN_CHK     (0x1) 
N#define DOMAIN_NOTCHK  (0x3) 
N#define DOMAIN0        (0x0<<5)
N#define DOMAIN1        (0x1<<5)
N
N#define DOMAIN0_ATTR   (DOMAIN_CHK<<0) 
N#define DOMAIN1_ATTR   (DOMAIN_FAULT<<2) 
N
N#define RW_CB          (AP_RW|DOMAIN0|CB|DESC_SEC)
N#define RW_CNB         (AP_RW|DOMAIN0|CNB|DESC_SEC)
N#define RW_NCNB        (AP_RW|DOMAIN0|NCNB|DESC_SEC)
N#define RW_FAULT       (AP_RW|DOMAIN1|NCNB|DESC_SEC)
N
N/* note: Reflect the changes in init.s */
N#define FLASH_SADDR  0x00000000 /* Flash starting address */
N#define SRAM_SADDR   0x40000000 /* SRAM starting address */
N#define SRAM_SIZE    (4*1024)   /* 4K internal SRAM */
N#define SFR_BADDR    0x48000000 /* SFR base address */
N
N#define SDRAM_SADDR  0x30000000 /* SDRAM starting address */
N#define SDRAM_SIZE   (64*1024*1024) /* 64M SDRAM */
N#define ISR_BADDR    0x33ffff00 /* ISR vector table start address */
N
N#define SRAM_EADDR   (SRAM_SADDR+SRAM_SIZE-1) /* SRAM end address */
N#define SDRAM_EADDR  (SDRAM_SADDR+SDRAM_SIZE-1) /* SRAM end address */
N
N#define MMUTT_SIZE   (16*1024) /* It has to be in multiples of 16K */
N#define MMUTT_SADDR  (SDRAM_SADDR) /* MMU Table start address */
N#define MMUTT_EADDR  (MMUTT_SADDR+MMUTT_SIZE)
N
Nint SET_IF(void);
Nvoid WR_IF(int cpsrValue);
Nvoid CLR_IF(void);
N
Nvoid MMU_EnableICache(void);
Nvoid MMU_DisableICache(void);
Nvoid MMU_EnableDCache(void);
Nvoid MMU_DisableDCache(void);
Nvoid MMU_EnableAlignFault(void);
Nvoid MMU_DisableAlignFault(void);
Nvoid MMU_EnableMMU(void);
Nvoid MMU_DisableMMU(void);
Nvoid MMU_SetTTBase(UINT32T base);
Xvoid MMU_SetTTBase(unsigned int base);
Nvoid MMU_SetDomain(UINT32T domain);
Xvoid MMU_SetDomain(unsigned int domain);
N
N//void MMU_SetFastBusMode(void);          //GCLK=HCLK
N//void MMU_SetAsyncBusMode(void);         //GCLK=FCLK @(FCLK>=HCLK)
N
Nvoid MMU_InvalidateIDCache(void);
Nvoid MMU_InvalidateICache(void);
Nvoid MMU_InvalidateICacheMVA(UINT32T mva);
Xvoid MMU_InvalidateICacheMVA(unsigned int mva);
Nvoid MMU_PrefetchICacheMVA(UINT32T mva);
Xvoid MMU_PrefetchICacheMVA(unsigned int mva);
Nvoid MMU_InvalidateDCache(void);
Nvoid MMU_InvalidateDCacheMVA(UINT32T mva);
Xvoid MMU_InvalidateDCacheMVA(unsigned int mva);
Nvoid MMU_CleanDCacheMVA(UINT32T mva);
Xvoid MMU_CleanDCacheMVA(unsigned int mva);
Nvoid MMU_CleanInvalidateDCacheMVA(UINT32T mva);
Xvoid MMU_CleanInvalidateDCacheMVA(unsigned int mva);
Nvoid MMU_CleanDCacheIndex(UINT32T index);
Xvoid MMU_CleanDCacheIndex(unsigned int index);
Nvoid MMU_CleanInvalidateDCacheIndex(UINT32T index); 
Xvoid MMU_CleanInvalidateDCacheIndex(unsigned int index); 
Nvoid MMU_WaitForInterrupt(void);
N        
Nvoid MMU_InvalidateTLB(void);
Nvoid MMU_InvalidateITLB(void);
Nvoid MMU_InvalidateITLBMVA(UINT32T mva);
Xvoid MMU_InvalidateITLBMVA(unsigned int mva);
Nvoid MMU_InvalidateDTLB(void);
Nvoid MMU_InvalidateDTLBMVA(UINT32T mva);
Xvoid MMU_InvalidateDTLBMVA(unsigned int mva);
N
Nvoid MMU_SetDCacheLockdownBase(UINT32T base);
Xvoid MMU_SetDCacheLockdownBase(unsigned int base);
Nvoid MMU_SetICacheLockdownBase(UINT32T base);
Xvoid MMU_SetICacheLockdownBase(unsigned int base);
N
Nvoid MMU_SetDTLBLockdown(UINT32T baseVictim);
Xvoid MMU_SetDTLBLockdown(unsigned int baseVictim);
Nvoid MMU_SetITLBLockdown(UINT32T baseVictim);
Xvoid MMU_SetITLBLockdown(unsigned int baseVictim);
N
Nvoid MMU_SetProcessId(UINT32T pid);
Xvoid MMU_SetProcessId(unsigned int pid);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif   //__2410slib_h__
L 18 "..\common\src\2410lib.c" 2
N
N/*------------------------------------------------------------------------------------------*/
N/*	 								global variable						 				    */
N/*------------------------------------------------------------------------------------------*/
Nstatic int delayLoopCount = FCLK/10000/10;				// the default count value for delay 
Xstatic int delayLoopCount = 202800000/10000/10;				
Nunsigned int f_nWhichUart=0;							// UARTx
Nchar Image$$RW_ZI$$ZI$$Limit[];
N
N/*********************************************************************************************
N* name:		port_init
N* func:		initialize io port for Embest teach kit iv
N* para:		none
N* ret:		none
N* comment:	
N*********************************************************************************************/
Nvoid port_init(void)
N{
N    //CAUTION:Follow the configuration order for setting the ports. 
N    // 1) setting control register (GPnCON)
N    //    * (bitn) -- means this pin not use on circuit, and set as default function
N    // 2) configure pull-up resistor (GPnUP)  
N    // 3) setting value (GPnDAT)
N
N    //32bit data bus configuration  
N    //=== PORT A GROUP
N    //Ports  : GPA22  GPA21  GPA20  GPA19  GPA18  GPA17  GPA16  GPA15  GPA14  GPA13  GPA12  
N    //Signal : nFCE   GPA21  nFRE   nFWE   ALE    CLE    GPA16  nGCS4  nGCS3  nGCS2  nGCS1 
N    //Setting: nFCE   Output nFRE   nFWE   ALE    CLE    Output nGCS4  nGCS3  nGCS2  nGCS1 
N    //Binary : 1      *0      1,     1      1      1      *0,    1      1      1      1
N    //----------------------------------------------------------------------------------------
N    //Ports  : GPA11  GPA10   GPA9   GPA8   GPA7   GPA6   GPA5   GPA4   GPA3   GPA2   GPA1   GPA0
N    //Signal : GPA11 ADDR25  ADDR24 ADDR23 ADDR22 ADDR21 ADDR20 ADDR19 ADDR18 ADDR17 ADDR16 ADDR0 
N    //Binary : *0     1       1      1,     1      1      1      1,     1      1      1      1         
N    rGPACON = 0x5fbfff;
X    (*(volatile unsigned *)0x56000000) = 0x5fbfff;
N
N    //===* PORT B GROUP
N    //Ports  : GPB10  GPB9   GPB8   GPB7   GPB6   GPB5    GPB4    GPB3   GPB2   GPB1  GPB0
N    //Signal : GPB10  GPB9   GPB8   GPB7   GPB6   DIS_OFF L3CLOCK L3DATA L3MODE PWM2  PWM1
N    //Setting: Output Output Output Output Output Output  Output  Output Output TOUT1 TOUT0 
N    //Binary : 01,    01     *01,   *01    *01,   01      01,     01     01,    10    10  
N    rGPBCON = 0x155559;
X    (*(volatile unsigned *)0x56000010) = 0x155559;
N    rGPBUP  = 0x7ff;      // The pull up function is disabled GPB[10:0]
X    (*(volatile unsigned *)0x56000018)  = 0x7ff;      
N
N    //=== PORT C GROUP
N    //Ports  : GPC15 GPC14 GPC13 GPC12 GPC11 GPC10 GPC9 GPC8 GPC7   GPC6   GPC5   GPC4 GPC3   GPC2  GPC1 GPC0
N    //Signal : VD7   VD6   VD5   VD4   VD3   VD2   VD1  VD0  Output Output Output OUT   VFRAME VLINE VCLK LEND  
N    //Binary : 10    10,   10    10,   10    10,   10   10,  *01    *01,   *01    01,  10     10,   10   10
N    rGPCCON = 0xaaaa55aa;       
X    (*(volatile unsigned *)0x56000020) = 0xaaaa55aa;       
N    rGPCUP  = 0xffff;     // The pull up function is disabled GPC[15:0] 
X    (*(volatile unsigned *)0x56000028)  = 0xffff;     
N
N    //=== PORT D GROUP
N    //Ports  : GPD15 GPD14 GPD13 GPD12 GPD11 GPD10 GPD9 GPD8 GPD7 GPD6 GPD5 GPD4 GPD3 GPD2 GPD1 GPD0
N    //Signal : VD23  VD22  VD21  VD20  VD19  VD18  VD17 VD16 VD15 VD14 VD13 VD12 VD11 VD10 VD9  VD8
N    //Binary : 10    10,   10    10,   10    10,   10   10,  10   10,  10   10,  10   10,  10   10
N    rGPDCON = 0xaaaaaaaa;       
X    (*(volatile unsigned *)0x56000030) = 0xaaaaaaaa;       
N    rGPDUP  = 0xffff;     // The pull up function is disabled GPD[15:0]
X    (*(volatile unsigned *)0x56000038)  = 0xffff;     
N
N    //=== PORT E GROUP
N    //Ports  : GPE15  GPE14  GPE13  GPE12   GPE11   GPE10   GPE9    GPE8     GPE7  GPE6  GPE5   GPE4  
N    //Signal : IICSDA IICSCL SPICLK SPIMOSI SPIMISO SDDATA3 SDDATA2 SDDATA1 SDDATA0 SDCMD SDCLK I2SSDO 
N    //Binary : 10     10,    10     10,     10      10,     10      10,      10    10,   10     10,       
N    //----------------------------------------------------------------------------------------
N    //Ports  :  GPE3   GPE2  GPE1    GPE0    
N    //Signal : I2SSDI CDCLK I2SSCLK I2SLRCK     
N    //Binary :  10     10,    10      10 
N    rGPECON = 0xa6aaaaaa;       
X    (*(volatile unsigned *)0x56000040) = 0xa6aaaaaa;       
N    rGPEUP  = 0xffff;     // The pull up function is disabled GPE[15:0]
X    (*(volatile unsigned *)0x56000048)  = 0xffff;     
N	rGPEDAT = 0x2000;
X	(*(volatile unsigned *)0x56000044) = 0x2000;
N    //=== PORT F GROUP
N    //Ports  : GPF7   GPF6   GPF5   GPF4   GPF3    GPF2      GPF1    GPF0
N    //Signal : LED_4  LED_3  LED_2  LED_1  PS2_INT CPLD_INT1 KEY_INT BUT_INT1
N    //Setting: Output Output Output Output EINT3   EINT2     EINT1   EINT0
N    //Binary : 01     01,    01     01,    10      10,       10      10
N    rGPFCON = 0x55aa;
X    (*(volatile unsigned *)0x56000050) = 0x55aa;
N    rGPFUP  = 0xff;     // The pull up function is disabled GPF[7:0]
X    (*(volatile unsigned *)0x56000058)  = 0xff;     
N
N    //=== PORT G GROUP
N    //Ports  : GPG15 GPG14 GPG13 GPG12 GPG11  GPG10  GPG9      GPG8      GPG7    GPG6    
N    //Signal : nYPON YMON  nXPON XMON  GPG11  SD_CD  CPLD_INT3 CPLD_INT2 SPICLK1 SPIMOSI
N    //Setting: nYPON YMON  nXPON XMON  Output Iutput EINT17    EINT17    SPICLK1 SPIMOSI1
N    //Binary : 11    11,   11    11,   01     00,    10        10,       11      11
N    //---------------------------------------------------------------------------------------
N    //Ports  : GPG5     GPG4      GPG3     GPG2 GPG1    GPG0    
N    //Signal : SPIMISO1 LCD_PWREN BUT_INT2 nSS0 NET_INT GPG0
N    //Setting: SPIMISO1 LCD_PWRDN EINT11   nSS0 EINT9   Output
N    //Binary : 11       11,       10       11,  10      *01
N    rGPGCON = 0xff4af7b9;
X    (*(volatile unsigned *)0x56000060) = 0xff4af7b9;
N    rGPGUP  = 0xffff;    // The pull up function is disabled GPG[15:0]
X    (*(volatile unsigned *)0x56000068)  = 0xffff;    
N
N    //rGPGCON = (rGPGCON & 0xfffffcff) | (1<<8);	// GPG4 [9:8] 11  -> LCD_PWREN Enable
N    // Eable LCD 
N    // rGPGDAT = (rGPGDAT & 0xffef) | (1<<4);
N    // close LCD 
N    rGPGDAT = rGPGDAT & 0xffcf;
X    (*(volatile unsigned *)0x56000064) = (*(volatile unsigned *)0x56000064) & 0xffcf;
N
N    //=== PORT H GROUP
N    //Ports  : GPH10 GPH9     GPH8   GPH7  GPH6  GPH5 GPH4 GPH3 GPH2 GPH1  GPH0 
N    //Signal : GPH10  CLKOUT0 SD_WP  CTS1  RTS1  RXD1 TXD1 RXD0 TXD0 nRTS0 nCTS0
N    //Setting: Output CLKOUT0 GPH8   nCTS1 nRTS1 RXD1 TXD1 RXD0 TXD0 nRTS0 nCTS0
N    //Binary : 10,    10      10,    11    11,   10   10,  10   10,  10    10
N    rGPHCON = 0x2aaaaa;
X    (*(volatile unsigned *)0x56000070) = 0x2aaaaa;
N    rGPHUP  = 0x7ff;    // The pull up function is disabled GPH[10:0]
X    (*(volatile unsigned *)0x56000078)  = 0x7ff;    
N    
N}
N
N/*********************************************************************************************
N* name:		uart_change_baud
N* func:		Change uart baud rate
N* para:		nChannel	-- 	input, UART0, UART1 or UART2
N*			nBaud		--	input, baud rate
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
Nvoid uart_change_baud(int nChannel, int nBaud)
N{
N    if (nChannel == UART0)
X    if (nChannel == 0x0)
N	    rUBRDIV0=( (int)(PCLK/16./nBaud + 0.5) -1 );
X	    (*(volatile unsigned *)0x50000028)=( (int)((202800000/4)/16./nBaud + 0.5) -1 );
N    
N    if (nChannel == UART1)
X    if (nChannel == 0x1)
N	    rUBRDIV1=( (int)(PCLK/16./nBaud) -1 );
X	    (*(volatile unsigned *)0x50004028)=( (int)((202800000/4)/16./nBaud) -1 );
N
N    if (nChannel == UART2)
X    if (nChannel == 0xBB)
N	    rUBRDIV2=( (int)(PCLK/16./nBaud) -1 );
X	    (*(volatile unsigned *)0x50008028)=( (int)((202800000/4)/16./nBaud) -1 );
N}
N
N/*********************************************************************************************
N* name:		uart_init
N* func:		initialize uart channel
N* para:		nMainClk	-- 	input, the MCLK value of current system
N*			nBaud		-- 	input, baud rate value for UARTx
N*			nChannel	-- 	input, UART0, UART1 or UART2
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
Nvoid uart_init(int nMainClk, int nBaud, int nChannel)
N{
N    int i;
N    
N    if(nMainClk == 0)
N    nMainClk    = PCLK;
X    nMainClk    = (202800000/4);
N
N    switch (nChannel)
N    {
N    	case UART0: 
X    	case 0x0: 
N			rUFCON0 = 0x0;   //UART channel 0 FIFO control register, FIFO disable
X			(*(volatile unsigned *)0x50000008) = 0x0;   
N			rUMCON0 = 0x0;   //UART chaneel 0 MODEM control register, AFC disable
X			(*(volatile unsigned *)0x5000000c) = 0x0;   
N			rULCON0 = 0x3;   //Line control register : Normal,No parity,1 stop,8 bits
X			(*(volatile unsigned *)0x50000000) = 0x3;   
N	// [10]       [9]     [8]     [7]          [6]      [5]        [4]         [3:2]          [1:0]
N	// Clock Sel, Tx Int, Rx Int, Rx Time Out, Rx err,  Loop-back, Send break, Transmit Mode, Receive Mode
N	// 0          1       0,      0            1        0          0,          01             01
N	// PCLK       Level   Pulse   Disable      Generate Normal     Normal      Interrupt or Polling
N			rUCON0  = 0x245;								// Control register
X			(*(volatile unsigned *)0x50000004)  = 0x245;								
N	//		rUBRDIV0=( (int)(nMainClk/16./nBaud) -1 );		// Baud rate divisior register 0
N			rUBRDIV0=( (int)(nMainClk/16./nBaud+0.5) -1 );	// Baud rate divisior register 0    
X			(*(volatile unsigned *)0x50000028)=( (int)(nMainClk/16./nBaud+0.5) -1 );	
N			break;
N			
N		case UART1: 
X		case 0x1: 
N			rUFCON1 = 0x0;   //UART channel 1 FIFO control register, FIFO disable
X			(*(volatile unsigned *)0x50004008) = 0x0;   
N			rUMCON1 = 0x0;   //UART chaneel 1 MODEM control register, AFC disable
X			(*(volatile unsigned *)0x5000400c) = 0x0;   
N			rULCON1 = 0x3;
X			(*(volatile unsigned *)0x50004000) = 0x3;
N			rUCON1  = 0x245;
X			(*(volatile unsigned *)0x50004004)  = 0x245;
N			rUBRDIV1=( (int)(nMainClk/16./nBaud) -1 );
X			(*(volatile unsigned *)0x50004028)=( (int)(nMainClk/16./nBaud) -1 );
N			break;
N			
N    	case UART2: 
X    	case 0xBB: 
N			rULCON2 = 0x3;
X			(*(volatile unsigned *)0x50008000) = 0x3;
N			rUCON2  = 0x245;
X			(*(volatile unsigned *)0x50008004)  = 0x245;
N			rUBRDIV2=( (int)(nMainClk/16./nBaud) -1 );    
X			(*(volatile unsigned *)0x50008028)=( (int)(nMainClk/16./nBaud) -1 );    
N			rUFCON2 = 0x0;   //UART channel 2 FIFO control register, FIFO disable
X			(*(volatile unsigned *)0x50008008) = 0x0;   
N			break;
N			
N		default:
N			break;
N	}
N
N    for(i=0;i<100;i++);
N    delay(400);
N}
N
N/*********************************************************************************************
N* name:		uart_select
N* func:		change uart channel
N* para:		nChannel	-- 	input, UART0, UART1 or UART2
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
Nvoid uart_select(int nChannel)
N{
N    f_nWhichUart=nChannel;
N}
N
N/*********************************************************************************************
N* name:		uart_txempty
N* func:		Empty uart channel
N* para:		nChannel	-- 	input, UART0, UART1 or UART2
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
Nvoid uart_txempty(int nChannel)
N{
N    if(nChannel==0)
N        while(!(rUTRSTAT0 & 0x4)); //Wait until tx shifter is empty.
X        while(!((*(volatile unsigned *)0x50000010) & 0x4)); 
N          
N    else if(nChannel==1)
N        while(!(rUTRSTAT1 & 0x4)); //Wait until tx shifter is empty.
X        while(!((*(volatile unsigned *)0x50004010) & 0x4)); 
N        
N    else if(nChannel==2)
N        while(!(rUTRSTAT2 & 0x4)); //Wait until tx shifter is empty.
X        while(!((*(volatile unsigned *)0x50008010) & 0x4)); 
N}
N
N/*********************************************************************************************
N* name:		uart_getch
N* func:		Get a character from the uart
N* para:		none
N* ret:		get a char from uart channel
N* modify:
N* comment:		
N*********************************************************************************************/
Nchar uart_getch(void)
N{
N    if(f_nWhichUart==0)
N    {       
N        while(!(rUTRSTAT0 & 0x1)); //Receive data ready
X        while(!((*(volatile unsigned *)0x50000010) & 0x1)); 
N        return RdURXH0();
X        return (*(volatile unsigned char *)0x50000024);
N    }
N    else if(f_nWhichUart==1)
N    {       
N        while(!(rUTRSTAT1 & 0x1)); //Receive data ready
X        while(!((*(volatile unsigned *)0x50004010) & 0x1)); 
N        return RdURXH1();
X        return (*(volatile unsigned char *)0x50004024);
N    }
N    else if(f_nWhichUart==2)
N    {
N        while(!(rUTRSTAT2 & 0x1)); //Receive data ready
X        while(!((*(volatile unsigned *)0x50008010) & 0x1)); 
N        return RdURXH2();
X        return (*(volatile unsigned char *)0x50008024);
N    }
N	return NULL;
X	return 0;
N}
N
N/*********************************************************************************************
N* name:		uart_getkey
N* func:		Get a key from the uart
N* para:		none
N* ret:		get a char from uart channel
N* modify:
N* comment:		
N*********************************************************************************************/
Nchar uart_getkey(void)
N{
N    if(f_nWhichUart==0)
N    {       
N        if(rUTRSTAT0 & 0x1)    //Receive data ready
X        if((*(volatile unsigned *)0x50000010) & 0x1)    
N            return RdURXH0();
X            return (*(volatile unsigned char *)0x50000024);
N        else
N            return 0;
N    }
N    else if(f_nWhichUart==1)
N    {
N        if(rUTRSTAT1 & 0x1)    //Receive data ready
X        if((*(volatile unsigned *)0x50004010) & 0x1)    
N            return RdURXH1();
X            return (*(volatile unsigned char *)0x50004024);
N        else
N            return 0;
N    }
N    else if(f_nWhichUart==2)
N    {       
N        if(rUTRSTAT2 & 0x1)    //Receive data ready
X        if((*(volatile unsigned *)0x50008010) & 0x1)    
N            return RdURXH2();
X            return (*(volatile unsigned char *)0x50008024);
N        else
N            return 0;
N    }    
N	return NULL;
X	return 0;
N}
N
N/*********************************************************************************************
N* name:		uart_getstring
N* func:		Get string from uart channel and store the result to input address (*pString)
N* para:		pString	-- 	input, string
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
Nvoid uart_getstring(char *pString)
N{
N    char *string2 = pString;
N    char c;
N    while((c = uart_getch())!='\r')
N    {
N        if(c=='\b')
N        {
N            if( (int)string2 < (int)pString )
N            {
N                uart_printf("\b \b");
N                pString--;
N            }
N        }
N        else 
N        {
N            *pString++ = c;
N            uart_sendbyte(c);
N        }
N    }
N    *pString='\0';
N    uart_sendbyte('\n');
N}
N
N/*********************************************************************************************
N* name:		uart_getintnum
N* func:		Get a numerical (Dec - default or Hex fromat) from the uart, with or without a signed
N* para:		none								  
N* ret:		nResult: the valid number which user input from uart
N* 					-- Dec format number (default)
N* 					-- Hex format number ('H/h' suffix or '0x' ahead)
N* modify:
N* comment:		
N*********************************************************************************************/
Nint uart_getintnum(void)
N{
N    char str[30];
N    char *pString = str;
N    int base     = 10;
N    int minus    = 0;
N    int nResult   = 0;
N    int lastIndex;    
N    int i;
N    
N    uart_getstring(pString);
N    
N    if(pString[0]=='-')
N    {
N        minus = 1;
N        pString++;
N    }
N    
N    if(pString[0]=='0' && (pString[1]=='x' || pString[1]=='X'))
N    {
N        base    = 16;
N        pString += 2;
N    }
N    
N    lastIndex = strlen(pString) - 1;
N    
N    if(lastIndex<0)
N        return -1;
N    
N    if(pString[lastIndex]=='h' || pString[lastIndex]=='H' )
N    {
N        base = 16;
N        pString[lastIndex] = 0;
N        lastIndex--;
N    }
N
N    if(base==10)
N    {
N        nResult = atoi(pString);
N        nResult = minus ? (-1*nResult):nResult;
N    }
N    else
N    {
N        for(i=0;i<=lastIndex;i++)
N        {
N            if(isalpha(pString[i]))
X            if(((* __rt_ctype_table())[pString[i]] & (16+8+128)))
N            {
N                if(isupper(pString[i]))
X                if(((* __rt_ctype_table())[pString[i]] & 16))
N                    nResult = (nResult<<4) + pString[i] - 'A' + 10;
N                else
N                    nResult = (nResult<<4) + pString[i] - 'a' + 10;
N            }
N            else
N                nResult = (nResult<<4) + pString[i] - '0';
N        }
N        nResult = minus ? (-1*nResult):nResult;
N    }
N    return nResult;
N}
N
N/*********************************************************************************************
N* name:		uart_sendbyte
N* func:		Send one byte to uart channel
N* para:		nData	-- 	input, byte
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
Nvoid uart_sendbyte(int nData)
N{
N    if(f_nWhichUart==0)
N    {
N        if(nData=='\n')
N        {
N            while(!(rUTRSTAT0 & 0x2));
X            while(!((*(volatile unsigned *)0x50000010) & 0x2));
N            delay(10);					//because the slow response of hyper_terminal 
N            WrUTXH0('\r');
X            (*(volatile unsigned char *)0x50000020)=(unsigned char)('\r');
N        }
N        while(!(rUTRSTAT0 & 0x2));		//Wait until THR is empty.
X        while(!((*(volatile unsigned *)0x50000010) & 0x2));		
N        delay(10);
N        WrUTXH0(nData);
X        (*(volatile unsigned char *)0x50000020)=(unsigned char)(nData);
N    }
N    else if(f_nWhichUart==1)
N    {
N        if(nData=='\n')
N        {
N            while(!(rUTRSTAT1 & 0x2));
X            while(!((*(volatile unsigned *)0x50004010) & 0x2));
N            delay(10);					//because the slow response of hyper_terminal 
N            rUTXH1 = '\r';
X            (*(volatile unsigned char *)0x50004020) = '\r';
N        }
N        while(!(rUTRSTAT1 & 0x2));		//Wait until THR is empty.
X        while(!((*(volatile unsigned *)0x50004010) & 0x2));		
N        delay(10);
N        rUTXH1 = nData;
X        (*(volatile unsigned char *)0x50004020) = nData;
N    }   
N    else if(f_nWhichUart==2)
N    {
N        if(nData=='\n')
N        {
N            while(!(rUTRSTAT2 & 0x2));
X            while(!((*(volatile unsigned *)0x50008010) & 0x2));
N            delay(10);					//because the slow response of hyper_terminal 
N            rUTXH2 = '\r';
X            (*(volatile unsigned char *)0x50008020) = '\r';
N        }
N        while(!(rUTRSTAT2 & 0x2));		//Wait until THR is empty.
X        while(!((*(volatile unsigned *)0x50008010) & 0x2));		
N        delay(10);
N        rUTXH2 = nData;
X        (*(volatile unsigned char *)0x50008020) = nData;
N    }       
N}               
N
N/*********************************************************************************************
N* name:		uart_sendstring
N* func:		Send string to uart channel
N* para:		pString	-- 	input, string
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
Nvoid uart_sendstring(char *pString)
N{
N    while(*pString)
N        uart_sendbyte(*pString++);
N}
N
N/*********************************************************************************************
N* name:		uart_printf
N* func:		print format string
N* para:		fmt	-- 	input,  
N* ret:		none
N* modify:
N* comment:  If you don't use vsprintf(), the code size is reduced very much.		
N*********************************************************************************************/
Nvoid uart_printf(char *fmt,...)
N{
N    va_list ap;
N    char pString[256];
N
N    va_start(ap,fmt);
X    __va_start(ap, fmt);
N    vsprintf(pString,fmt,ap);
N    uart_sendstring(pString);
N    va_end(ap);
X    __va_end(ap);
N}
N
N/*********************************************************************************************
N* name:		timer_start
N* func:		start timer
N* para:		nDivider	-- 	input, 0:16us,1:32us 2:64us 3:128us
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
Nvoid timer_start(int divider)  
N{
N    rWTCON = ((PCLK/1000000-1)<<8)|(divider<<3); //Watch-dog timer control register
X    (*(volatile unsigned *)0x53000000) = (((202800000/4)/1000000-1)<<8)|(divider<<3); 
N    rWTDAT = 0xffff;							 //Watch-dog timer data register
X    (*(volatile unsigned *)0x53000004) = 0xffff;							 
N    rWTCNT = 0xffff;							 //Watch-dog count register
X    (*(volatile unsigned *)0x53000008) = 0xffff;							 
N
N    rWTCON = rWTCON | (1<<5) | ~(1<<2);  		 //May 06, 2002 SOP
X    (*(volatile unsigned *)0x53000000) = (*(volatile unsigned *)0x53000000) | (1<<5) | ~(1<<2);  		 
N}
N
N/*********************************************************************************************
N* name:		timer_stop
N* func:		stop timer
N* para:		none
N* ret:			--	int, timer count
N* modify:
N* comment:		
N*********************************************************************************************/
Nint timer_stop(void)
N{
N    rWTCON = ((PCLK/1000000-1)<<8);
X    (*(volatile unsigned *)0x53000000) = (((202800000/4)/1000000-1)<<8);
N    return (0xffff - rWTCNT);
X    return (0xffff - (*(volatile unsigned *)0x53000008));
N}
N
N/*********************************************************************************************
N* name:		change_value_MPLL
N* func:		change MPLL value
N* para:		none
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
Nvoid change_value_MPLL(int nMdiv,int nPdiv,int nSdiv)
N{
N    rMPLLCON = (nMdiv<<12) | (nPdiv<<4) | nSdiv;
X    (*(volatile unsigned *)0x4c000004) = (nMdiv<<12) | (nPdiv<<4) | nSdiv;
N}
N
N/*********************************************************************************************
N* name:		change_clock_divider
N* func:		change the clock frequance
N* para:		none
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
Nvoid change_clock_divider(int nHdiv,int nPdiv)
N{
N     // nHdiv,nPdiv FCLK:HCLK:PCLK
N     //     0,0         1:1:1 
N     //     0,1         1:1:2 
N     //     1,0         1:2:2
N     //     1,1         1:2:4
N    rCLKDIVN = (nHdiv<<1) | nPdiv;    
X    (*(volatile unsigned *)0x4c000014) = (nHdiv<<1) | nPdiv;    
N    
N}
N
N/*********************************************************************************************
N* name:		ChangeUPllValue
N* func:		change the parameter nMdiv,nPdiv,nSdiv
N* para:		none
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
Nvoid ChangeUPllValue(int nMdiv,int nPdiv,int nSdiv)
N{
N    rUPLLCON = (nMdiv<<12) | (nPdiv<<4) | nSdiv;
X    (*(volatile unsigned *)0x4c000008) = (nMdiv<<12) | (nPdiv<<4) | nSdiv;
N}
N
N/*********************************************************************************************
N* name:		delay
N* func:		delay time
N* para:		nTime -- input, nTime=0: nAdjust the delay function by WatchDog timer.
N*						    nTime>0: the number of loop time, 100us resolution.
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
Nvoid delay(int nTime)
N{
N      // time=0: adjust the Delay function by WatchDog timer.
N      // time>0: the number of loop time
N      // resolution of time is 100us.
N    int i,adjust=0;
N    if(nTime==0)
N    {
N        nTime   = 200;
N        adjust = 1;
N        delayLoopCount = 400;
N		//PCLK/1M,Watch-dog disable,1/64,interrupt disable,reset disable
N        rWTCON = ((PCLK/1000000-1)<<8)|(2<<3); 
X        (*(volatile unsigned *)0x53000000) = (((202800000/4)/1000000-1)<<8)|(2<<3); 
N        rWTDAT = 0xffff;                             	//for first update
X        (*(volatile unsigned *)0x53000004) = 0xffff;                             	
N        rWTCNT = 0xffff;                             	//resolution=64us @any PCLK 
X        (*(volatile unsigned *)0x53000008) = 0xffff;                             	
N        rWTCON = ((PCLK/1000000-1)<<8)|(2<<3)|(1<<5); 	//Watch-dog timer start
X        (*(volatile unsigned *)0x53000000) = (((202800000/4)/1000000-1)<<8)|(2<<3)|(1<<5); 	
N    }
N    for(;nTime>0;nTime--)
N        for(i=0;i<delayLoopCount;i++);
N    if(adjust==1)
N    {
N        rWTCON = ((PCLK/1000000-1)<<8)|(2<<3);   		//Watch-dog timer stop
X        (*(volatile unsigned *)0x53000000) = (((202800000/4)/1000000-1)<<8)|(2<<3);   		
N        i = 0xffff - rWTCNT;                     		//1count->64us, 200*400 cycle runtime = 64*i us
X        i = 0xffff - (*(volatile unsigned *)0x53000008);                     		
N        delayLoopCount = 8000000/(i*64);         		//200*400:64*i=1*x:100 -> x=80000*100/(64*i)   
N    }
N}
N
N/*********************************************************************************************
N* name:		EnableMMU
N* func:		Enable the MMU
N* para:		none
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
Nvoid EnableMMU()
N{
N	unsigned int ctl;
N
N	ctl = ARM_ReadControl();
N	ctl |= (1 << 0);
N	ARM_WriteControl(ctl);
N}
N
N/*********************************************************************************************
N* name:		InitMMU
N* func:		Initialization the MMU
N* para:		pTranslationTable-TranslationTable Address
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
Nvoid InitMMU(unsigned int *pTranslationTable)
N{
N	int i;
N	// Program the TTB
N	ARM_WriteTTB((unsigned int) pTranslationTable);
N	// Program the domain access register
N	ARM_WriteDomain(0xC0000000); 		// domain 15: access are not checked
N
N	// Reset table entries
N	for (i = 0; i < 0x200; ++i)
N		pTranslationTable[i] = 0;
N
N	// Program level 1 page table entry
N	pTranslationTable[0x0] =
N		(0x300 << 20) |  				// Physical Address
N		(1 << 10) |      				// Access in supervisor mode
N		(15 << 5) |      				// Domain
N		1 << 4 |
N		0x2;             				// Set as 1 Mbyte section
N	pTranslationTable[0x1] =
N		(0x301 << 20) |  				// Physical Address
N		(1 << 10) |      				// Access in supervisor mode
N		(15 << 5) |      				// Domain
N		1 << 4 |
N		0x2;             				// Set as 1 Mbyte section
N	pTranslationTable[0x2] =
N		(0x302 << 20) |  				// Physical Address
N		(1 << 10) |      				// Access in supervisor mode
N		(15 << 5) |      				// Domain
N		1 << 4 |
N		0x2;             				// Set as 1 Mbyte section
N	pTranslationTable[0x3] =
N		(0x303 << 20) |  				// Physical Address
N		(1 << 10) |      				// Access in supervisor mode
N		(15 << 5) |      				// Domain
N		1 << 4 |
N		0x2;             				// Set as 1 Mbyte section
N
N	for(i = 0x200; i < 0xFFF; ++i)
N		pTranslationTable[i] = 
N			(i << 20) |  				// Physical Address
N			(1 << 10) |      			// Access in supervisor mode
N			(15 << 5) |      			// Domain
N			1 << 4 |
N			0x2;             			// Set as 1 Mbyte section
N
N	EnableMMU();		 				// Enable the MMU
N}
N
N/*********************************************************************************************
N* name:		__gccmain
N* func:		the entry point of gcc library
N* para:		none
N* ret:		none
N* modify:
N* comment:		
N*********************************************************************************************/
Nvoid __gccmain(void)
N{
N}
